--- File: vite.config.js ---

import { defineConfig } from 'vite'
import react from '@vitejs/plugin-react'
import cesium from 'vite-plugin-cesium'

// https://vite.dev/config/
export default defineConfig({
  plugins: [react(), cesium()],
})


--- End of File: vite.config.js ---

--- File: eslint.config.js ---

import js from '@eslint/js'
import globals from 'globals'
import reactHooks from 'eslint-plugin-react-hooks'
import reactRefresh from 'eslint-plugin-react-refresh'
import { defineConfig, globalIgnores } from 'eslint/config'

export default defineConfig([
  globalIgnores(['dist']),
  {
    files: ['**/*.{js,jsx}'],
    extends: [
      js.configs.recommended,
      reactHooks.configs['recommended-latest'],
      reactRefresh.configs.vite,
    ],
    languageOptions: {
      ecmaVersion: 2020,
      globals: globals.browser,
      parserOptions: {
        ecmaVersion: 'latest',
        ecmaFeatures: { jsx: true },
        sourceType: 'module',
      },
    },
    rules: {
      'no-unused-vars': ['error', { varsIgnorePattern: '^[A-Z_]' }],
    },
  },
])


--- End of File: eslint.config.js ---

--- File: src/main.jsx ---

import { StrictMode } from 'react'
import { createRoot } from 'react-dom/client'
import './index.css'
import App from './App.jsx'

createRoot(document.getElementById('root')).render(
  <StrictMode>
    <App />
  </StrictMode>,
)


--- End of File: src/main.jsx ---

--- File: src/App.jsx ---

import { CesiumViewer } from './components';

function App() {
  return (
    <>
      <CesiumViewer />
    </>
  );
}

export default App;


--- End of File: src/App.jsx ---

--- File: src/components/index.jsx ---

export { default as CesiumViewer } from './CesiumViewer';
export { default as FlightControls } from './FlightControls';
export { default as AircraftSelector } from './AircraftSelector';
export { default as GlobalViewToggle } from './GlobalViewToggle';
export { default as EnterPrompt } from './EnterPrompt';
export { default as AttitudeIndicator } from './AttitudeIndicator';
export { default as RadarMap } from './RadarMap';
export { default as InstrumentPanel } from './InstrumentPanel';
export { default as WaypointControl } from './WaypointControl';
export { default as WaypointNavigation } from './WaypointNavigation';
export { default as LoadingScreen } from './LoadingScreen';

--- End of File: src/components/index.jsx ---

--- File: src/components/FlightControls/index.jsx ---

// src/components/FlightControls/index.jsx

import { useEffect, useState } from 'react';
import * as Cesium from 'cesium';
import { CoordinateConverter } from '../../helpers/CoordinateConverter';

const FlightControls = ({ flightData, isAutoFlying, isAutoFlightPaused }) => {
    if (!flightData) return null;

    const { speed, position, heading, pitch, roll, status } = flightData;
    const cartographic = position ? Cesium.Cartographic.fromCartesian(position) : null;
    const altitude = cartographic ? Math.round(cartographic.height) : 0;
    
    // å°†Cesium headingï¼ˆä¸œæ–¹0åº¦ï¼‰è½¬æ¢ä¸ºèˆªç©ºæ–¹ä½è§’ï¼ˆåŒ—æ–¹0åº¦ï¼‰
    const headingDeg = CoordinateConverter.cesiumHeadingToBearing(
        Cesium.Math.toDegrees(heading)
    );

    const [crashTextColor, setCrashTextColor] = useState('orange');

    useEffect(() => {
        if (status?.isCrashed) {
            const interval = setInterval(() => {
                setCrashTextColor(prev => prev === 'orange' ? 'purple' : 'orange');
            }, 500);

            return () => clearInterval(interval);
        }
    }, [status?.isCrashed]);

    
    return (
        <div style={containerStyle}>
            <h3 style={headerStyle}>é£è¡Œæ•°æ®</h3>
            
            <div style={{ display: 'grid', gap: '10px' }}>
                <DataRow label="é€Ÿåº¦" value={`${Math.round(speed * 3.6)} km/h`} />
                <DataRow label="ç»åº¦" value={`${(Cesium.Math.toDegrees(cartographic.longitude)).toFixed(6)}Â°`} />
                <DataRow label="çº¬åº¦" value={`${(Cesium.Math.toDegrees(cartographic.latitude)).toFixed(6)}Â°`} />
                <DataRow label="é«˜åº¦" value={`${altitude} m`} />
                <DataRow label="èˆªå‘" value={`${Math.round(headingDeg)}Â°`} />
                <DataRow label="ä¿¯ä»°" value={`${Math.round(Cesium.Math.toDegrees(pitch))}Â°`} />
                <DataRow label="ç¿»æ»š" value={`${Math.round(Cesium.Math.toDegrees(roll))}Â°`} />
            </div>

            {(status && (status.isStalled || status.isSupersonic || status.isCrashed) || isAutoFlying) &&
                <div style={statusContainerStyle}>
                    {isAutoFlying && !isAutoFlightPaused && <div style={{ color: 'cyan', fontWeight: 'bold' }}>è‡ªåŠ¨é©¾é©¶å·²å¯åŠ¨</div>}
                    {isAutoFlying && isAutoFlightPaused && <div style={{ color: 'yellow', fontWeight: 'bold' }}>è‡ªåŠ¨é©¾é©¶å·²æš‚åœ (æ‰‹åŠ¨æ§åˆ¶)</div>}
                    {status.isCrashed && <div style={{ color: crashTextColor, fontWeight: 'bold' }}>MAN! WHAT CAN I SAY?</div>}
                    {status.isStalled && <div style={{ color: 'red', fontWeight: 'bold' }}>å¤±é€Ÿè­¦å‘Š!</div>}
                    {status.isSupersonic && <div style={{ color: 'cyan', fontWeight: 'bold' }}>éŸ³çˆ†!</div>}
                </div>
            }
            
            {(!isAutoFlying || isAutoFlightPaused) && (
                <div style={controlsInfoStyle}>
                    <div><strong>æ§åˆ¶è¯´æ˜:</strong></div>
                    <div>W/S: ä¿¯å†²/æŠ¬å‡ | A/D: å·¦æ»š/å³æ»š</div>
                    <div>Q/E: å·¦è½¬/å³è½¬ | Shift/Ctrl: åŠ é€Ÿ/å‡é€Ÿ</div>
                </div>
            )}
        </div>
    );
};

const containerStyle = {
    position: 'absolute', top: '20px', left: '20px',
    backgroundColor: 'rgba(0, 0, 0, 0.7)', color: '#00ff00',
    padding: '20px', borderRadius: '10px', fontFamily: 'monospace',
    fontSize: '14px', zIndex: 1000, minWidth: '250px'
};
const headerStyle = {
    margin: '0 0 15px 0', color: '#00ff00',
    borderBottom: '2px solid #00ff00', paddingBottom: '10px'
};
const statusContainerStyle = {
    marginTop: '15px', paddingTop: '10px',
    borderTop: '1px dashed #555'
};
const controlsInfoStyle = {
    marginTop: '20px', paddingTop: '15px',
    borderTop: '1px solid #00ff00', fontSize: '12px', color: '#88ff88'
};

const DataRow = ({ label, value }) => (
    <div style={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center' }}>
        <span style={{ color: '#88ff88' }}>{label}:</span>
        <span style={{ fontWeight: 'bold', fontSize: '16px' }}>{value}</span>
    </div>
);


export default FlightControls;

--- End of File: src/components/FlightControls/index.jsx ---

--- File: src/components/CesiumViewer/index.jsx ---

// components/CesiumViewer/index.jsx

import * as Cesium from "cesium";
import "cesium/Build/Cesium/Widgets/widgets.css";
import { useEffect, useRef, useState } from "react";
import { FlightSimulator } from "../../helpers/FlightSimulator";
import { AIRCRAFT_LIST } from "../../config/aircraftConfig";
import { WaypointManager } from "../../helpers/WaypointManager";

import {
    FlightControls,
    AircraftSelector,
    GlobalViewToggle,
    EnterPrompt,
    InstrumentPanel,
    WaypointControl,
    WaypointNavigation,
    LoadingScreen
} from '../index';

Cesium.Ion.defaultAccessToken = import.meta.env.VITE_CESIUM_ION_TOKEN;

function CesiumViewer() {
    const cesiumContainerRef = useRef(null);
    const simulatorRef = useRef(null);
    const [viewer, setViewer] = useState(null);
    const [flightData, setFlightData] = useState(null);
    const [currentAircraftId, setCurrentAircraftId] = useState(null);
    const [viewMode, setViewMode] = useState('FLIGHT');
    const [showPrompt, setShowPrompt] = useState(true);
    const [audioReady, setAudioReady] = useState(false);

    const [waypointManager, setWaypointManager] = useState(null);
    const [isNavigating, setIsNavigating] = useState(false);
    const [waypoints, setWaypoints] = useState([]);

    useEffect(() => {
        if (!cesiumContainerRef.current) return;

        let viewer;
        let simulator;
        let handler;
        let manager;
        let isMounted = true;

        const init = async () => {
            try {
                viewer = new Cesium.Viewer(cesiumContainerRef.current, {
                    terrain: Cesium.Terrain.fromWorldTerrain(),
                    infoBox: false, geocoder: false, homeButton: false,
                    sceneModePicker: false, baseLayerPicker: false,
                    navigationHelpButton: false, animation: false,
                    timeline: true, fullscreenButton: false,
                    vrButton: false, selectionIndicator: false,
                    shadows: true, shouldAnimate: true,
                    targetFrameRate: 60
                });

                if (isMounted) setViewer(viewer);
                
                viewer._cesiumWidget._creditContainer.style.display = "none";
                viewer.scene.globe.depthTestAgainstTerrain = true;
                viewer.scene.globe.enableLighting = true;

                const google_sat = await Cesium.IonImageryProvider.fromAssetId(3830182);
                google_sat.dayAlpha = 0.0;
                google_sat.nightAlpha = 1.0;
                viewer.imageryLayers.addImageryProvider(google_sat);
                const osm_building = await Cesium.Cesium3DTileset.fromIonAssetId(96188);
                viewer.scene.primitives.add(osm_building);

                if (!isMounted) return;

                manager = new WaypointManager(viewer);
                if (isMounted) setWaypointManager(manager);

                simulator = new FlightSimulator(viewer, manager);
                simulatorRef.current = simulator;

                simulator.on('audioLoaded', () => isMounted && setAudioReady(true));
                simulator.on('audioUnlocked', () => isMounted && setShowPrompt(false));

                const onFlightDataUpdate = (data) => {
                    if (isMounted) {
                        setFlightData({ ...data });
                    }
                };
                simulator.on('flightDataUpdate', onFlightDataUpdate);

                handler = new Cesium.ScreenSpaceEventHandler(viewer.scene.canvas);
                handler.setInputAction(async (movement) => {
                    if (simulatorRef.current && simulatorRef.current.viewMode === 'GLOBAL') {
                        const cartesian = viewer.scene.pickPosition(movement.position);
                        if (Cesium.defined(cartesian)) {
                            await simulatorRef.current.relocateAircraft(cartesian);
                            setViewMode('FLIGHT');
                        }
                    }
                }, Cesium.ScreenSpaceEventType.LEFT_DOUBLE_CLICK);
                
                const defaultAircraft = AIRCRAFT_LIST[0];
                const initialLon = 121.47, initialLat = 31.23, initialAgl = 1500;
                const initialCartographic = Cesium.Cartographic.fromDegrees(initialLon, initialLat);

                const [updatedInitialCarto] = await simulator.getUpdatedCartographicsWithTerrainHeight([initialCartographic]);
                updatedInitialCarto.height += initialAgl;
                const initialPosition = Cesium.Cartographic.toCartesian(updatedInitialCarto);

                simulator.loadAircraft(defaultAircraft, initialPosition, Cesium.Math.toRadians(-90));
                setCurrentAircraftId(defaultAircraft.id);
                
            } catch (error) {
                console.error("Failed to initialise Cesium viewer:", error);
            }
        };

        init();

        return () => {
            isMounted = false;
            if (handler) handler.destroy();
            if (manager) manager.destroy();
            if (simulator) simulator.destroy();
            if (viewer) viewer.destroy();
        };
    }, []);

    useEffect(() => {
        if (!waypointManager) return;

        const updateWaypoints = () => {
            setWaypoints(waypointManager.getWaypoints());
        };

        const handleNavigationCompleted = () => {
            console.log('Navigation mission accomplished!');
            setIsNavigating(false);
        };

        updateWaypoints();

        waypointManager.on('waypointAdded', updateWaypoints);
        waypointManager.on('waypointRemoved', updateWaypoints);
        waypointManager.on('waypointsCleared', updateWaypoints);
        waypointManager.on('waypointReached', updateWaypoints);
        waypointManager.on('navigationCompleted', handleNavigationCompleted);

        return () => {
            waypointManager.off('waypointAdded', updateWaypoints);
            waypointManager.off('waypointRemoved', updateWaypoints);
            waypointManager.off('waypointsCleared', updateWaypoints);
            waypointManager.off('waypointReached', updateWaypoints);
            waypointManager.off('navigationCompleted', handleNavigationCompleted);
        };
    }, [waypointManager]);


    const handleAudioUnlock = async () => {
        if (simulatorRef.current) {
            await simulatorRef.current.unlockAudio();
            simulatorRef.current.start();
        }
    };

    const handleAircraftSelect = (aircraftConfig) => {
        if (simulatorRef.current && currentAircraftId !== aircraftConfig.id) {
            const prev = simulatorRef.current.currentAircraft.state;
            const currentPosition = Cesium.Cartesian3.clone(prev.position);
            const currentOrientation = Cesium.Quaternion.clone(prev.orientation);

            simulatorRef.current.loadAircraft(
                aircraftConfig,
                currentPosition,
                undefined,
                currentOrientation
            );
            setCurrentAircraftId(aircraftConfig.id);
        }
    };

    const handleToggleViewMode = () => {
        const newMode = viewMode === 'FLIGHT' ? 'GLOBAL' : 'FLIGHT';
        if (simulatorRef.current) {
            simulatorRef.current.setViewMode(newMode);
            setViewMode(newMode);
        }
    };

    const handleNavigationStart = () => setIsNavigating(true);
    const handleNavigationStop = () => setIsNavigating(false);

    return (
        <div style={{ width: '100%', height: '100vh', position: 'relative' }}>
            {!audioReady && <LoadingScreen />}

            <div ref={cesiumContainerRef} style={{ width: '100%', height: '100%' }} />
            
            {isNavigating && flightData?.navigationData && (
                <WaypointNavigation
                    navigationData={flightData.navigationData}
                    flightData={flightData}
                />
            )}

            {showPrompt && audioReady && (
                <EnterPrompt onUnlock={handleAudioUnlock} />
            )}

            {!showPrompt && (
                <>
                    <FlightControls flightData={flightData} />
                    <AircraftSelector onSelect={handleAircraftSelect} currentAircraftId={currentAircraftId} />
                    <GlobalViewToggle viewMode={viewMode} onToggle={handleToggleViewMode} />
                    <InstrumentPanel flightData={flightData} waypoints={waypoints} />
                    {waypointManager && (
                        <WaypointControl
                            waypointManager={waypointManager}
                            isNavigating={isNavigating}
                            onNavigationStart={handleNavigationStart}
                            onNavigationStop={handleNavigationStop}
                            viewer={viewer}
                        />
                    )}
                </>    
            )}
        </div>
    );
}

export default CesiumViewer;

--- End of File: src/components/CesiumViewer/index.jsx ---

--- File: src/components/RadarMap/index.jsx ---

// components/RadarMap/index.jsx

import { useEffect, useRef } from 'react';
import * as Cesium from 'cesium';

import { CoordinateConverter } from '../../helpers/CoordinateConverter';

const RadarMap = ({ position, heading, terrainData, landmarks, waypoints }) => {
    const canvasRef = useRef(null);

    useEffect(() => {
        const canvas = canvasRef.current;
        if (!canvas || !position) return;

        const ctx = canvas.getContext('2d');
        const size = 200;
        const centerX = size / 2;
        const centerY = size / 2;
        const mapRadius = size / 2 - 20;
        const maxDisplayDistance = 50000;

        ctx.clearRect(0, 0, size, size);
        ctx.fillStyle = 'rgba(0, 20, 0, 0.9)';
        ctx.fillRect(0, 0, size, size);

        // ç»˜åˆ¶é›·è¾¾åœˆå’Œåå­—çº¿
        ctx.strokeStyle = '#00ff00';
        ctx.lineWidth = 1;
        for (let i = 1; i <= 3; i++) {
            ctx.beginPath();
            ctx.arc(centerX, centerY, (mapRadius / 3) * i, 0, Math.PI * 2);
            ctx.stroke();
        }

        ctx.beginPath();
        ctx.moveTo(centerX, centerY - mapRadius);
        ctx.lineTo(centerX, centerY + mapRadius);
        ctx.moveTo(centerX - mapRadius, centerY);
        ctx.lineTo(centerX + mapRadius, centerY);
        ctx.stroke();

        // ç»˜åˆ¶æ–¹å‘æ ‡è®°
        ctx.fillStyle = '#00ff00';
        ctx.font = '12px monospace';
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        
        // å°†Cesium headingè½¬æ¢ä¸ºèˆªç©ºbearingç”¨äºæ˜¾ç¤º
        const aircraftBearing = CoordinateConverter.cesiumHeadingToBearing(
            Cesium.Math.toDegrees(heading)
        );
        
        const directions = [
            { label: 'N', angle: 0 }, 
            { label: 'E', angle: 90 }, 
            { label: 'S', angle: 180 }, 
            { label: 'W', angle: 270 }
        ];
        
        directions.forEach(dir => {
            // ç›¸å¯¹äºé£æœºèˆªå‘çš„è§’åº¦å·®
            const relativeAngle = (dir.angle - aircraftBearing + 360) % 360;
            const angleRad = Cesium.Math.toRadians(relativeAngle);
            const x = centerX + Math.sin(angleRad) * (mapRadius + 10);
            const y = centerY - Math.cos(angleRad) * (mapRadius + 10);
            ctx.fillText(dir.label, x, y);
        });

        const cartographic = Cesium.Cartographic.fromCartesian(position);

        // ç»˜åˆ¶èˆªç‚¹
        if (waypoints && waypoints.length > 0) {
            const waypointScreenCoords = waypoints.map(wp => {
                const distance = Cesium.Cartesian3.distance(position, wp.position);
                if (distance >= maxDisplayDistance) return null;

                // è®¡ç®—èˆªç©ºæ–¹ä½è§’
                const bearing = CoordinateConverter.calculateBearing(
                    Cesium.Math.toDegrees(cartographic.longitude),
                    Cesium.Math.toDegrees(cartographic.latitude),
                    wp.longitude,
                    wp.latitude
                );
                
                // è®¡ç®—ç›¸å¯¹æ–¹ä½è§’ï¼ˆç›®æ ‡æ–¹ä½ - é£æœºèˆªå‘ï¼‰
                const relativeBearing = (bearing - aircraftBearing + 360) % 360;
                const relativeBearingRad = Cesium.Math.toRadians(relativeBearing);
                const displayDistance = (distance / maxDisplayDistance) * mapRadius;
                
                return {
                    x: centerX + Math.sin(relativeBearingRad) * displayDistance,
                    y: centerY - Math.cos(relativeBearingRad) * displayDistance,
                    waypoint: wp
                };
            });

            // ç»˜åˆ¶è·¯å¾„å’Œèˆªç‚¹æ ‡è®°
            ctx.strokeStyle = '#00ffff';
            ctx.lineWidth = 1.5;
            ctx.setLineDash([5, 5]);
            ctx.beginPath();
            let firstPoint = true;
            waypointScreenCoords.forEach(coord => {
                if (coord) {
                    if (firstPoint) {
                        ctx.moveTo(coord.x, coord.y);
                        firstPoint = false;
                    } else {
                        ctx.lineTo(coord.x, coord.y);
                    }
                }
            });
            ctx.stroke();
            ctx.setLineDash([]);

            waypointScreenCoords.forEach((coord, index) => {
                if (coord) {
                    const { x, y, waypoint } = coord;
                    ctx.fillStyle = waypoint.reached ? '#00ff00' : '#ffff00';
                    ctx.strokeStyle = '#ffffff';
                    ctx.lineWidth = 1;
                    ctx.fillRect(x - 3, y - 3, 6, 6);
                    ctx.strokeRect(x - 3, y - 3, 6, 6);

                    ctx.fillStyle = '#ffffff';
                    ctx.font = '10px monospace';
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'bottom';
                    ctx.fillText((index + 1).toString(), x, y - 5);
                }
            });
        }

        // ç»˜åˆ¶åœ°æ ‡
        if (landmarks && landmarks.length > 0) {
            landmarks.forEach(landmark => {
                const lmCartographic = Cesium.Cartographic.fromDegrees(landmark.longitude, landmark.latitude);
                const distance = Cesium.Cartesian3.distance(
                    position, 
                    Cesium.Cartesian3.fromRadians(lmCartographic.longitude, lmCartographic.latitude, cartographic.height)
                );
                
                if (distance < maxDisplayDistance) {
                    const bearing = CoordinateConverter.calculateBearing(
                        Cesium.Math.toDegrees(cartographic.longitude), 
                        Cesium.Math.toDegrees(cartographic.latitude), 
                        landmark.longitude, 
                        landmark.latitude
                    );
                    
                    const relativeBearing = (bearing - aircraftBearing + 360) % 360;
                    const relativeBearingRad = Cesium.Math.toRadians(relativeBearing);
                    const displayDistance = (distance / maxDisplayDistance) * mapRadius;
                    const x = centerX + Math.sin(relativeBearingRad) * displayDistance;
                    const y = centerY - Math.cos(relativeBearingRad) * displayDistance;
                    
                    ctx.fillStyle = landmark.color || '#ffff00';
                    ctx.beginPath();
                    ctx.arc(x, y, 4, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.fillStyle = landmark.color || '#ffff00';
                    ctx.font = '10px monospace';
                    ctx.fillText(landmark.name, x + 8, y);
                }
            });
        }

        // ç»˜åˆ¶é£æœºå›¾æ ‡ã€æ‰«æçº¿ã€è¾¹æ¡†
        ctx.save();
        ctx.translate(centerX, centerY);
        ctx.fillStyle = '#ff0000';
        ctx.beginPath();
        ctx.moveTo(0, -10); 
        ctx.lineTo(-6, 8); 
        ctx.lineTo(6, 8);
        ctx.closePath(); 
        ctx.fill();
        ctx.restore();

        const time = Date.now() % 2000;
        const scanAngle = (time / 2000) * Math.PI * 2;
        const gradient = ctx.createLinearGradient(
            centerX, centerY, 
            centerX + Math.cos(scanAngle) * mapRadius, 
            centerY + Math.sin(scanAngle) * mapRadius
        );
        gradient.addColorStop(0, 'rgba(0, 255, 0, 0.3)');
        gradient.addColorStop(1, 'rgba(0, 255, 0, 0)');
        ctx.strokeStyle = gradient;
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.moveTo(centerX, centerY);
        ctx.lineTo(
            centerX + Math.cos(scanAngle) * mapRadius, 
            centerY + Math.sin(scanAngle) * mapRadius
        );
        ctx.stroke();

        ctx.strokeStyle = '#00ff00';
        ctx.lineWidth = 2;
        ctx.strokeRect(1, 1, size - 2, size - 2);

    }, [position, heading, terrainData, landmarks, waypoints]);

    return (
        <div style={containerStyle}>
            <div style={labelStyle}>é›·è¾¾/å°åœ°å›¾</div>
            <canvas 
                ref={canvasRef} 
                width={200} 
                height={200}
                style={canvasStyle}
            />
            <div style={scaleStyle}>
                <div>è·ç¦»åˆ»åº¦</div>
                <div>å¤–åœˆ: ~50km</div>
            </div>
        </div>
    );
};

const containerStyle = { backgroundColor: 'rgba(0, 0, 0, 0.7)', padding: '10px', borderRadius: '10px', border: '2px solid #00ff00' };
const labelStyle = { color: '#00ff00', fontFamily: 'monospace', fontSize: '14px', fontWeight: 'bold', marginBottom: '5px', textAlign: 'center' };
const canvasStyle = { display: 'block', border: '1px solid #00ff00', borderRadius: '5px' };
const scaleStyle = { marginTop: '5px', color: '#00ff00', fontFamily: 'monospace', fontSize: '10px', textAlign: 'center' };

export default RadarMap;

--- End of File: src/components/RadarMap/index.jsx ---

--- File: src/components/AircraftSelector/index.jsx ---

// src/components/AircraftSelector/index.jsx

import { AIRCRAFT_LIST } from '../../config/aircraftConfig';

const selectorStyle = {
    position: 'absolute',
    top: '20px',
    right: '20px',
    backgroundColor: 'rgba(0, 0, 0, 0.7)',
    padding: '10px',
    borderRadius: '5px',
    zIndex: 1000,
};

const buttonStyle = {
    display: 'block',
    width: '100%',
    padding: '8px',
    margin: '5px 0',
    backgroundColor: '#333',
    color: '#00ff00',
    border: '1px solid #00ff00',
    cursor: 'pointer',
};

const AircraftSelector = ({ onSelect, currentAircraftId, disabled }) => {
    return (
        <div style={selectorStyle}>
            <h4 style={{ color: 'white', margin: '0 0 10px 0' }}>é€‰æ‹©é£æœº</h4>
            {AIRCRAFT_LIST.map(craft => (
                <button
                    key={craft.id}
                    onClick={() => onSelect(craft)}
                    disabled={disabled}
                    style={{
                        ...buttonStyle,
                        backgroundColor: currentAircraftId === craft.id ? '#00ff00' : '#333',
                        color: currentAircraftId === craft.id ? '#000' : '#00ff00',
                        cursor: disabled ? 'not-allowed' : 'pointer',
                        opacity: disabled ? 0.5 : 1,
                    }}
                >
                    {craft.name}
                </button>
            ))}
        </div>
    );
};

export default AircraftSelector;

--- End of File: src/components/AircraftSelector/index.jsx ---

--- File: src/components/LoadingScreen/index.jsx ---

// src/components/LoadingScreen/index.jsx

const MESSAGE = "æ­£åœ¨åˆå§‹åŒ–...";

const LoadingScreen = () => {
    return (
        <div style={overlayStyle}>
            <div style={containerStyle}>
                <div className="spinner" style={spinnerStyle}></div>
                <h2 style={titleStyle}>Flight Simulator</h2>
                <p style={messageStyle}>{MESSAGE}</p>
            </div>
        </div>
    );
};

// æ ·å¼å®šä¹‰
const overlayStyle = {
    position: 'fixed',
    inset: 0,
    width: '100vw',
    height: '100vh',
    backgroundColor: 'rgba(0, 0, 0, 0.95)',
    display: 'flex',
    justifyContent: 'center',
    alignItems: 'center',
    zIndex: 10000,
    backdropFilter: 'blur(5px)',
    color: '#00ff00',
    fontFamily: 'monospace',
};

const containerStyle = {
    textAlign: 'center',
    display: 'flex',
    flexDirection: 'column',
    alignItems: 'center',
    gap: '20px',
};

const spinnerStyle = {
    width: '60px',
    height: '60px',
    border: '5px solid rgba(0, 255, 0, 0.2)',
    borderTopColor: '#00ff00',
    borderRadius: '50%',
};

const titleStyle = {
    fontSize: '28px',
    margin: 0,
    textShadow: '0 0 10px rgba(0, 255, 0, 0.7)',
    letterSpacing: '2px',
};

const messageStyle = {
    fontSize: '16px',
    color: '#9ee89e',
    margin: 0,
    minHeight: '20px', // é˜²æ­¢æ–‡å­—åˆ‡æ¢æ—¶å¸ƒå±€è·³åŠ¨
    transition: 'opacity 0.5s ease-in-out',
};

export default LoadingScreen;

--- End of File: src/components/LoadingScreen/index.jsx ---

--- File: src/components/GlobalViewToggle/index.jsx ---

// src/components/GlobalViewToggle/index.jsx

const containerStyle = {
    position: 'absolute',
    bottom: '40px',
    left: '50%',
    transform: 'translateX(-50%)',
    zIndex: 1000,
    textAlign: 'center'
};

const buttonStyle = {
    padding: '10px 20px',
    backgroundColor: 'rgba(0, 0, 0, 0.7)',
    color: '#00ff00',
    border: '2px solid #00ff00',
    borderRadius: '5px',
    cursor: 'pointer',
    fontFamily: 'monospace',
    fontSize: '16px',
    outline: 'none',
    minWidth: '150px',
    transition: 'background-color 0.2s, color 0.2s',
};

const tooltipStyle = {
    color: 'white',
    fontSize: '12px',
    marginTop: '5px',
    textShadow: '1px 1px 2px black'
};

const GlobalViewToggle = ({ viewMode, onToggle }) => {
    return (
        <div style={containerStyle}>
            <button 
                onClick={onToggle} 
                style={buttonStyle}
                onMouseOver={e => { e.currentTarget.style.backgroundColor = '#00ff00'; e.currentTarget.style.color = '#000'; }}
                onMouseOut={e => { e.currentTarget.style.backgroundColor = 'rgba(0, 0, 0, 0.7)'; e.currentTarget.style.color = '#00ff00'; }}
            >
                {viewMode === 'FLIGHT' ? 'ğŸŒ å…¨çƒè§†å›¾' : 'âœˆï¸ è¿”å›é£è¡Œ'}
            </button>
            {viewMode === 'GLOBAL' && (
                <div style={tooltipStyle}>
                    åŒå‡»åœ°çƒè¡¨é¢ä»¥ç§»åŠ¨é£æœºè‡³è¯¥ä½ç½®
                </div>
            )}
            {viewMode === 'FLIGHT' && (
                <div style={tooltipStyle}>
                    ç‚¹å‡»ä»¥ç§»åŠ¨åˆ°å…¨çƒè§†è§’
                </div>
            )}
        </div>
    );
};

export default GlobalViewToggle;

--- End of File: src/components/GlobalViewToggle/index.jsx ---

--- File: src/components/WaypointControl/index.jsx ---

// src/components/WaypointControl/index.jsx

import { useEffect, useState, useCallback } from 'react';
import { LANDMARKS } from '../../config/landmarksConfig';
import * as Cesium from 'cesium';

const WaypointControl = ({ waypointManager, isNavigating, onNavigationStart, onNavigationStop, viewer, isAutoFlying }) => {
    const [showPanel, setShowPanel] = useState(false);
    const [waypoints, setWaypoints] = useState([]);
    const [selectedLandmark, setSelectedLandmark] = useState('');
    const [altitude, setAltitude] = useState(1000);
    
    const [manualInput, setManualInput] = useState({
        name: '',
        latitude: '',
        longitude: '',
        altitude: 1000
    });
    const [showManualInput, setShowManualInput] = useState(false);

    const [clickAddMode, setClickAddMode] = useState(false);

    useEffect(() => {
        if (!waypointManager) return;

        const updateWaypoints = () => {
            setWaypoints(waypointManager.getWaypoints());
        };

        updateWaypoints();

        waypointManager.on('waypointAdded', updateWaypoints);
        waypointManager.on('waypointRemoved', updateWaypoints);
        waypointManager.on('waypointsCleared', updateWaypoints);

        return () => {
            waypointManager.off('waypointAdded', updateWaypoints);
            waypointManager.off('waypointRemoved', updateWaypoints);
            waypointManager.off('waypointsCleared', updateWaypoints);
        };
    }, [waypointManager]);

    const handleMapClick = useCallback(async (movement) => {
        if (!waypointManager || !viewer) return;

        const cartesian = viewer.scene.pickPosition(movement.position);
        if (Cesium.defined(cartesian)) {
            const cartographic = Cesium.Cartographic.fromCartesian(cartesian);
            const lat = Cesium.Math.toDegrees(cartographic.latitude);
            const lon = Cesium.Math.toDegrees(cartographic.longitude);
            const aglAltitude = 1000; // å¯¹åœ°é«˜åº¦1000ç±³

            await waypointManager.addWaypoint(
                lon,
                lat,
                aglAltitude,
                `èˆªç‚¹ ${waypoints.length + 1}`
            );
        }
    }, [waypointManager, viewer, waypoints.length]);

    useEffect(() => {
        if (!viewer || !clickAddMode) {
            return;
        }

        const handler = new Cesium.ScreenSpaceEventHandler(viewer.scene.canvas);
        handler.setInputAction(handleMapClick, Cesium.ScreenSpaceEventType.LEFT_CLICK);

        return () => {
            if (handler && !handler.isDestroyed()) {
                handler.destroy();
            }
        };
    }, [viewer, clickAddMode, handleMapClick]);

    const handleAddLandmark = async () => {
        if (!selectedLandmark || !waypointManager) return;

        const landmark = LANDMARKS.find(l => l.name === selectedLandmark);
        if (landmark) {
            await waypointManager.addWaypointFromLandmark(landmark, altitude);
            setSelectedLandmark('');
        }
    };

    const handleAddManualWaypoint = async () => {
        if (!waypointManager) return;

        const lat = parseFloat(manualInput.latitude);
        const lon = parseFloat(manualInput.longitude);
        const alt = parseFloat(manualInput.altitude);

        if (isNaN(lat) || isNaN(lon) || isNaN(alt)) {
            alert('è¯·è¾“å…¥æœ‰æ•ˆçš„åæ ‡å’Œé«˜åº¦');
            return;
        }

        if (lat < -90 || lat > 90) {
            alert('çº¬åº¦å¿…é¡»åœ¨ -90 åˆ° 90 ä¹‹é—´');
            return;
        }

        if (lon < -180 || lon > 180) {
            alert('ç»åº¦å¿…é¡»åœ¨ -180 åˆ° 180 ä¹‹é—´');
            return;
        }

        const waypointName = manualInput.name || `èˆªç‚¹ ${waypoints.length + 1}`;
        await waypointManager.addWaypoint(lon, lat, alt, waypointName);

        setManualInput({
            name: '',
            latitude: '',
            longitude: '',
            altitude: 1000
        });
        setShowManualInput(false);
    };

    const handleRemoveWaypoint = (waypointId) => {
        if (waypointManager) {
            waypointManager.removeWaypoint(waypointId);
        }
    };

    const handleClearAll = () => {
        if (waypointManager && window.confirm('ç¡®å®šè¦æ¸…é™¤æ‰€æœ‰èˆªç‚¹å—ï¼Ÿ')) {
            waypointManager.clearWaypoints();
        }
    };

    const handleStartNavigation = () => {
        if (waypointManager && waypointManager.startNavigation()) {
            onNavigationStart?.();
        }
    };

    const handleStopNavigation = () => {
        if (waypointManager) {
            waypointManager.stopNavigation();
            onNavigationStop?.();
        }
    };

    return (
        <div style={containerStyle}>
            <button 
                style={toggleButtonStyle}
                onClick={() => setShowPanel(!showPanel)}
            >
                {showPanel ? 'âœ•' : 'ğŸ“'} èˆªç‚¹ç®¡ç†
            </button>

            {showPanel && (
                <div style={panelStyle}>
                    <h3 style={headerStyle}>èˆªç‚¹ç®¡ç†</h3>

                    <div style={sectionStyle}>
                        <label style={labelStyle}>æ·»åŠ èˆªç‚¹æ–¹å¼:</label>
                        <div style={addMethodButtonsStyle}>
                            <button
                                style={{
                                    ...methodButtonStyle,
                                    backgroundColor: !showManualInput && !clickAddMode ? '#003300' : 'transparent'
                                }}
                                onClick={() => {
                                    setShowManualInput(false);
                                    setClickAddMode(false);
                                }}
                            >
                                ğŸ“ åœ°æ ‡
                            </button>
                            <button
                                style={{
                                    ...methodButtonStyle,
                                    backgroundColor: showManualInput ? '#003300' : 'transparent'
                                }}
                                onClick={() => {
                                    if (showManualInput) {
                                        setShowManualInput(false);
                                    } else {
                                        setShowManualInput(true);
                                        setClickAddMode(false);
                                    }
                                }}
                            >
                                âŒ¨ï¸ æ‰‹åŠ¨è¾“å…¥
                            </button>
                            <button
                                style={{
                                    ...methodButtonStyle,
                                    backgroundColor: clickAddMode ? '#003300' : 'transparent',
                                    border: clickAddMode ? '2px solid #ffff00' : '1px solid #00ff00'
                                }}
                                onClick={() => {
                                    if (clickAddMode) {
                                        setClickAddMode(false);
                                    } else {
                                        setShowManualInput(false);
                                        setClickAddMode(true);
                                    }
                                }}
                            >
                                ğŸ–±ï¸ ç‚¹å‡»åœ°å›¾
                            </button>
                        </div>
                        {clickAddMode && (
                            <div style={clickModeHintStyle}>
                                âœ¨ åœ°å›¾ç‚¹å‡»æ¨¡å¼å·²å¯ç”¨ï¼Œå•å‡»åœ°å›¾æ·»åŠ èˆªç‚¹
                            </div>
                        )}
                    </div>

                    {showManualInput && (
                        <div style={manualInputSectionStyle}>
                            <input
                                type="text"
                                placeholder="èˆªç‚¹åç§°ï¼ˆå¯é€‰ï¼‰"
                                style={inputStyle}
                                value={manualInput.name}
                                onChange={(e) => setManualInput({...manualInput, name: e.target.value})}
                            />
                            <div style={coordRowStyle}>
                                <input
                                    type="number"
                                    className="no-spin"
                                    placeholder="çº¬åº¦ (-90 ~ 90)"
                                    style={{...inputStyle, width: '48%'}}
                                    value={manualInput.latitude}
                                    onChange={(e) => setManualInput({...manualInput, latitude: e.target.value})}
                                    step="0.0001"
                                />
                                <input
                                    type="number"
                                    className="no-spin"
                                    placeholder="ç»åº¦ (-180 ~ 180)"
                                    style={{...inputStyle, width: '48%'}}
                                    value={manualInput.longitude}
                                    onChange={(e) => setManualInput({...manualInput, longitude: e.target.value})}
                                    step="0.0001"
                                />
                            </div>
                            <input
                                type="number"
                                className="no-spin"
                                placeholder="å¯¹åœ°é«˜åº¦ (ç±³)"
                                style={inputStyle}
                                value={manualInput.altitude}
                                onChange={(e) => setManualInput({...manualInput, altitude: e.target.value})}
                                min="100"
                                max="15000"
                                step="100"
                            />
                            <button 
                                style={addButtonStyle}
                                onClick={handleAddManualWaypoint}
                            >
                                â• æ·»åŠ èˆªç‚¹
                            </button>
                        </div>
                    )}

                    {!showManualInput && !clickAddMode && (
                        <div style={sectionStyle}>
                            <label style={labelStyle}>é€‰æ‹©åœ°æ ‡:</label>
                            <select 
                                style={selectStyle}
                                value={selectedLandmark}
                                onChange={(e) => setSelectedLandmark(e.target.value)}
                            >
                                <option value="">é€‰æ‹©åœ°æ ‡...</option>
                                {LANDMARKS.map(landmark => (
                                    <option key={landmark.name} value={landmark.name}>
                                        {landmark.name}
                                    </option>
                                ))}
                            </select>

                            <div style={altitudeRowStyle}>
                                <label style={labelStyle}>å¯¹åœ°é«˜åº¦ (ç±³):</label>
                                <input
                                    type="number"
                                    className="no-spin"
                                    style={inputStyle}
                                    value={altitude}
                                    onChange={(e) => setAltitude(Number(e.target.value))}
                                    min="100"
                                    max="15000"
                                    step="100"
                                />
                            </div>

                            <button 
                                style={addButtonStyle}
                                onClick={handleAddLandmark}
                                disabled={!selectedLandmark}
                            >
                                â• æ·»åŠ èˆªç‚¹
                            </button>
                        </div>
                    )}

                    <div style={sectionStyle}>
                        <div style={listHeaderStyle}>
                            <span>èˆªç‚¹åˆ—è¡¨ ({waypoints.length})</span>
                            {waypoints.length > 0 && (
                                <button 
                                    style={clearButtonStyle}
                                    onClick={handleClearAll}
                                >
                                    æ¸…ç©º
                                </button>
                            )}
                        </div>

                        <div style={waypointListStyle}>
                            {waypoints.length === 0 ? (
                                <div style={emptyStyle}>æš‚æ— èˆªç‚¹</div>
                            ) : (
                                waypoints.map((wp, index) => (
                                    <div 
                                        key={wp.id} 
                                        style={{
                                            ...waypointItemStyle,
                                            backgroundColor: wp.reached ? 'rgba(0, 255, 0, 0.1)' : 'rgba(0, 0, 0, 0.3)'
                                        }}
                                    >
                                        <div style={waypointNumberStyle}>
                                            {index + 1}
                                        </div>
                                        <div style={waypointDetailsStyle}>
                                            <div style={waypointNameItemStyle}>
                                                {wp.name}
                                                {wp.reached && <span style={reachedBadgeStyle}>âœ“</span>}
                                            </div>
                                            <div style={waypointCoordsStyle}>
                                                {wp.latitude.toFixed(4)}Â°, {wp.longitude.toFixed(4)}Â° @ {Math.round(wp.altitude)}m
                                            </div>
                                        </div>
                                        {!wp.reached && (
                                            <button 
                                                style={removeButtonStyle}
                                                onClick={() => handleRemoveWaypoint(wp.id)}
                                            >
                                                âœ•
                                            </button>
                                        )}
                                    </div>
                                ))
                            )}
                        </div>
                    </div>

                    <div style={sectionStyle}>
                        {!isNavigating ? (
                            <button 
                                style={{ ...navButtonStyle, backgroundColor: '#00aa00' }}
                                onClick={handleStartNavigation}
                                disabled={waypoints.length === 0 || isAutoFlying}
                            >
                                ğŸš€ å¼€å§‹å¯¼èˆª
                            </button>
                        ) : (
                            <button 
                                style={{
                                    ...navButtonStyle,
                                    backgroundColor: isAutoFlying ? '#555' : '#aa0000',
                                    cursor: isAutoFlying ? 'not-allowed' : 'pointer'
                                }}
                                onClick={handleStopNavigation}
                                disabled={isAutoFlying}
                            >
                                {isAutoFlying ? 'âœˆï¸ è‡ªåŠ¨é£è¡Œä¸­...' : 'â¹ï¸ åœæ­¢å¯¼èˆª'}
                            </button>
                        )}
                    </div>

                    <div style={hintStyle}>
                        ğŸ’¡ æç¤º: é«˜åº¦è¾“å…¥ç°åœ¨æ˜¯ç›¸å¯¹äºåœ°é¢çš„é«˜åº¦ã€‚
                    </div>
                </div>
            )}
        </div>
    );
};

const addMethodButtonsStyle = { display: 'flex', gap: '8px', marginBottom: '10px', };
const methodButtonStyle = { flex: 1, padding: '8px', backgroundColor: 'transparent', border: '1px solid #00ff00', color: '#00ff00', borderRadius: '4px', cursor: 'pointer', fontFamily: 'monospace', fontSize: '12px', transition: 'all 0.2s', };
const manualInputSectionStyle = { backgroundColor: 'rgba(0, 50, 0, 0.2)', border: '1px solid #00ff00', borderRadius: '6px', padding: '12px', marginBottom: '15px', };
const coordRowStyle = { display: 'flex', justifyContent: 'space-between', gap: '4%', };
const clickModeHintStyle = { color: '#ffff00', fontSize: '11px', marginTop: '5px', padding: '6px', backgroundColor: 'rgba(255, 255, 0, 0.1)', borderRadius: '4px', textAlign: 'center', };
const containerStyle = { position: 'absolute', bottom: '40px', right: '20px', zIndex: 1000, };
const toggleButtonStyle = { backgroundColor: 'rgba(0, 0, 0, 0.7)', border: '2px solid #00ff00', color: '#00ff00', padding: '10px 15px', borderRadius: '5px', cursor: 'pointer', fontFamily: 'monospace', fontSize: '14px', fontWeight: 'bold', };
const panelStyle = { backgroundColor: 'rgba(0, 0, 0, 0.9)', border: '2px solid #00ff00', borderRadius: '10px', padding: '15px', marginTop: '10px', width: '350px', maxHeight: '70vh', overflowY: 'auto', fontFamily: 'monospace', };
const headerStyle = { color: '#00ff00', margin: '0 0 15px 0', fontSize: '18px', borderBottom: '2px solid #00ff00', paddingBottom: '10px', };
const sectionStyle = { marginBottom: '15px', };
const labelStyle = { display: 'block', color: '#00ff00', marginBottom: '6px', fontSize: '12px', };
const selectStyle = { width: '100%', padding: '8px', backgroundColor: 'rgba(0,0,0,0.6)', color: '#00ff00', border: '1px solid #00ff00', borderRadius: '4px', marginBottom: '10px', fontFamily: 'monospace', };
const inputStyle = { width: '100%', padding: '8px', backgroundColor: 'rgba(0,0,0,0.6)', color: '#00ff00', border: '1px solid #00ff00', borderRadius: '4px', marginBottom: '10px', fontFamily: 'monospace', display: 'flex', boxSizing: 'border-box', paddingRight: '12px', };
const altitudeRowStyle = { display: 'flex', flexDirection: 'column', gap: '6px', width: '100%', };
const addButtonStyle = { width: '100%', backgroundColor: '#003300', border: '1px solid #00ff00', color: '#00ff00', padding: '8px', borderRadius: '4px', cursor: 'pointer', fontFamily: 'monospace', };
const listHeaderStyle = { display: 'flex', alignItems: 'center', justifyContent: 'space-between', color: '#00ff00', marginBottom: '8px', };
const clearButtonStyle = { backgroundColor: 'transparent', border: '1px solid #ff4444', color: '#ff4444', padding: '4px 8px', borderRadius: '4px', cursor: 'pointer', fontFamily: 'monospace', fontSize: '12px', };
const waypointListStyle = { display: 'flex', flexDirection: 'column', gap: '8px', };
const emptyStyle = { color: '#888', textAlign: 'center', padding: '12px 0', };
const waypointItemStyle = { display: 'flex', alignItems: 'center', gap: '10px', border: '1px solid #00ff00', borderRadius: '6px', padding: '8px', };
const waypointNumberStyle = { minWidth: '28px', height: '28px', lineHeight: '28px', textAlign: 'center', borderRadius: '50%', border: '1px solid #00ff00', color: '#00ff00', fontFamily: 'monospace', };
const waypointDetailsStyle = { flex: 1, display: 'flex', flexDirection: 'column', gap: '3px', };
const waypointNameItemStyle = { color: '#00ff00', fontWeight: 'bold', display: 'flex', alignItems: 'center', gap: '6px', };
const reachedBadgeStyle = { color: '#00ff00', border: '1px solid #00ff00', borderRadius: '4px', padding: '0 4px', fontSize: '10px', };
const waypointCoordsStyle = { color: '#9ee89e', fontSize: '12px', fontFamily: 'monospace', };
const removeButtonStyle = { backgroundColor: 'transparent', border: '1px solid #ff4444', color: '#ff4444', padding: '4px 8px', borderRadius: '4px', cursor: 'pointer', fontFamily: 'monospace', };
const navButtonStyle = { width: '100%', border: '1px solid #00ff00', color: '#fff', padding: '10px', borderRadius: '6px', cursor: 'pointer', fontFamily: 'monospace', };
const hintStyle = { color: '#9ee89e', fontSize: '12px', marginTop: '8px', };

export default WaypointControl;

--- End of File: src/components/WaypointControl/index.jsx ---

--- File: src/components/EnterPrompt/index.jsx ---

// components/EnterPrompt/index.jsx

import { useState } from 'react';

const overlayStyle = {
    position: 'fixed',
    inset: 0,
    width: '100vw',
    height: '100vh',
    backgroundColor: 'rgba(0, 0, 0, 0.85)',
    display: 'flex',
    justifyContent: 'center',
    alignItems: 'center',
    zIndex: 9999,
    backdropFilter: 'blur(6px)'
};

const containerStyle = {
    display: 'flex',
    gridTemplateColumns: '1.1fr 0.9fr',
    gap: '24px',
    backgroundColor: 'rgba(20, 20, 20, 0.95)',
    padding: '32px',
    borderRadius: '16px',
    border: '2px solid #00ff00',
    boxShadow: '0 0 30px rgba(0, 255, 0, 0.25)',
    width: 'fit-content',
};

const leftColStyle = {
    display: 'flex',
    flexDirection: 'column',
    gap: '16px',
    minWidth: 0,
};

const badgeStyle = {
    alignSelf: 'flex-start',
    color: '#001800',
    backgroundColor: '#00ff00',
    borderRadius: '999px',
    padding: '4px 10px',
    fontFamily: 'monospace',
    fontSize: '12px',
    fontWeight: 'bold',
    boxShadow: '0 0 10px rgba(0,255,0,.3)'
};

const titleStyle = {
    color: '#00ff00',
    fontSize: '28px',
    margin: 0,
    fontFamily: 'monospace',
    textShadow: '0 0 10px rgba(0, 255, 0, 0.5)'
};

const subtitleStyle = {
    color: '#9ee89e',
    margin: 0,
    fontSize: '14px',
    lineHeight: 1.6
};

const panelStyle = {
    border: '1px solid #00ff00',
    borderRadius: '12px',
    padding: '14px',
    background: 'rgba(0,0,0,0.35)',
    color: '#cceccc',
    fontFamily: 'monospace'
};

const panelHeaderStyle = {
    color: '#00ff00',
    fontSize: '14px',
    marginBottom: '8px',
    fontWeight: 'bold',
    borderBottom: '1px dashed #00ff00',
    paddingBottom: '6px'
};

const emphasisStyle = {
    fontFamily: 'monospace',
    display: 'inline-block',
    padding: '2px 6px',
    background: 'rgba(255,90,0,0.15)',
    border: '1px solid #ff5a00',
    borderRadius: '6px',
    color: '#ff7b1f',
    fontWeight: 'bold',
    textShadow: '0 0 6px rgba(255,120,0,0.6)',
    boxShadow: '0 0 8px rgba(255,120,0,0.4)',
};

const shortcutBoxStyle = {
    display: 'grid',
    gridTemplateColumns: '1fr 1fr',
    gap: '6px',
    color: '#cceccc',
    fontSize: '12px'
};

const keyStyle = {
    display: 'inline-block',
    border: '1px solid #00ff00',
    borderRadius: '6px',
    padding: '2px 6px',
    color: '#00ff00',
    marginRight: '6px',
    minWidth: '28px',
    textAlign: 'center'
};

const buttonBarStyle = {
    display: 'flex',
    gap: '12px',
    marginTop: '8px',
};

const startButtonStyle = (hovered) => ({
    padding: '14px 26px',
    fontSize: '16px',
    backgroundColor: hovered ? '#00cc00' : '#00cc0039',
    color: hovered ? '#000000ff' : '#00cc00',
    border: hovered ? '2px solid #14ff3bff' : '2px solid #00cc00',
    borderRadius: '8px',
    cursor: 'pointer',
    fontFamily: 'monospace',
    fontWeight: 'bold',
    transition: 'all 0.25s ease',
    boxShadow: hovered ? '0 0 24px rgba(0, 255, 0, 0.5)' : '0 0 16px rgba(0, 0, 0, 0)',
    transform: hovered ? 'translateY(-1px)' : 'translateY(0)',
    width: '200px',
});

const EnterPrompt = ({ onUnlock }) => {
    const [hover, setHover] = useState(false);
    const [audioEnabled] = useState(true);

    const handleStart = () => {
        try {
            onUnlock?.({ audioEnabled });
        } catch {
            onUnlock?.();
        }
    };

    return (
        <div style={overlayStyle}>
            <div style={containerStyle}>
                <div style={leftColStyle}>
                    <span style={badgeStyle}>Flight Simulator</span>
                    <h2 style={titleStyle}>æ¬¢è¿è¿›å…¥é£è¡Œæ¨¡æ‹Ÿ</h2>
                    <p style={subtitleStyle}>
                        ä½“éªŒé«˜é€Ÿä¿¯å†²ã€ç²¾å‡†æœºåŠ¨ä¸å…¨çƒèˆªç‚¹å¯¼èˆªã€‚å¯ç”¨éŸ³æ•ˆä»¥è·å¾—å¼•æ“ã€å¤±é€Ÿä¸éŸ³çˆ†çš„æ²‰æµ¸å¼ä½“éªŒã€‚
                    </p>

                    <div style={{ ...panelStyle, marginTop: '6px' }}>
                        <div style={panelHeaderStyle}>å¿«æ·é”®</div>
                        <div style={shortcutBoxStyle}>
                            <div><span style={keyStyle}>W/S</span>ä¿¯å†² / æŠ¬å‡</div>
                            <div><span style={keyStyle}>A/D</span>å·¦æ»š / å³æ»š</div>
                            <div><span style={keyStyle}>Q/E</span>å·¦è½¬ / å³è½¬</div>
                            <div><span style={keyStyle}>Shift/Ctrl</span>åŠ é€Ÿ / å‡é€Ÿ</div>
                        </div>
                    </div>                   

                    <div style={panelStyle}>
                        <div style={panelHeaderStyle}>æ³¨æ„äº‹é¡¹</div>
                        <div style={{ color: '#cceccc', fontSize: '12px', lineHeight: 1.6 }}>
                            - å»ºè®®åœ¨æ¡Œé¢æµè§ˆå™¨è¿è¡Œä»¥è·å¾—æœ€ä½³ä½“éªŒã€‚<br />
                            - å¦‚æœçœ‹ä¸åˆ°åœ°å½¢æˆ–å½±åƒï¼Œè¯·æ£€æŸ¥ç½‘ç»œä¸ Cesium Ion Tokenã€‚<br />
                            - ç‚¹å‡»â€œå¼€å§‹é£è¡Œâ€å°†åˆ›å»ºç”¨æˆ·æ‰‹åŠ¿ä»¥è§£é”éŸ³é¢‘ã€‚
                        </div>
                    </div>

                    <span style={emphasisStyle}>ç”±äºéœ€è¦å®æ—¶åŠ è½½å¹¶è®¡ç®—åœ°å½¢ç¢°æ’ï¼Œæµç•…åº¦å–å†³äºç½‘ç»œä¸è®¾å¤‡æ€§èƒ½ã€‚</span>

                    
                    <div style={buttonBarStyle}>
                        <button
                            style={startButtonStyle(hover)}
                            onMouseEnter={() => setHover(true)}
                            onMouseLeave={() => setHover(false)}
                            onClick={handleStart}
                        >
                            æˆ‘æ˜ç™½ï¼Œå¼€å§‹é£è¡Œ
                        </button>
                    </div>
                </div>
            </div>
        </div>
    );
};

export default EnterPrompt;

--- End of File: src/components/EnterPrompt/index.jsx ---

--- File: src/components/WaypointNavigation/index.jsx ---

// components/WaypointNavigation/index.jsx

import { useState } from 'react';
import * as Cesium from 'cesium';

import { CoordinateConverter } from '../../helpers/CoordinateConverter';

const WaypointNavigation = ({ waypointManager, navigationData, flightData }) => {
    const [showPanel, setShowPanel] = useState(true);

    if (!navigationData && !waypointManager) return null;

    const { currentWaypoint, distance, bearing, elevationDiff, eta, currentIndex, totalWaypoints } = navigationData || {};

    // è®¡ç®—ç›¸å¯¹èˆªå‘ï¼ˆç›®æ ‡æ–¹ä½ - å½“å‰èˆªå‘ï¼‰
    const getRelativeHeading = () => {
        if (!bearing || !flightData) return 0;
        
        // å°†Cesium headingè½¬æ¢ä¸ºèˆªç©ºbearing
        const aircraftBearing = CoordinateConverter.cesiumHeadingToBearing(
            Cesium.Math.toDegrees(flightData.heading)
        );
        
        // è®¡ç®—å·®å€¼
        const diff = bearing - aircraftBearing;
        
        // å½’ä¸€åŒ–åˆ° -180 åˆ° 180
        return ((diff + 180) % 360) - 180;
    };

    const relativeHeading = getRelativeHeading();

    return (
        <div style={containerStyle}>
            {showPanel && navigationData && (
                <div style={navPanelStyle}>
                    <div style={headerStyle}>
                        <span>ğŸ¯ èˆªç‚¹å¯¼èˆª</span>
                        <button 
                            style={toggleButtonStyle}
                            onClick={() => setShowPanel(false)}
                        >
                            â”€
                        </button>
                    </div>

                    <div style={waypointInfoStyle}>
                        <div style={waypointNameStyle}>
                            {currentWaypoint?.name}
                        </div>
                        <div style={progressStyle}>
                            èˆªç‚¹ {currentIndex + 1} / {totalWaypoints}
                        </div>
                    </div>

                    <div style={directionIndicatorContainerStyle}>
                        <DirectionIndicator 
                            relativeHeading={relativeHeading}
                            distance={distance}
                        />
                    </div>

                    <div style={dataGridStyle}>
                        <DataItem 
                            label="è·ç¦»" 
                            value={`${(distance / 1000).toFixed(2)} km`}
                            color="#00ff00"
                        />
                        <DataItem 
                            label="æ–¹ä½" 
                            value={`${Math.round(bearing)}Â°`}
                            color="#00ffff"
                        />
                        <DataItem 
                            label="é«˜åº¦å·®" 
                            value={`${elevationDiff > 0 ? '+' : ''}${Math.round(elevationDiff)} m`}
                            color={elevationDiff > 0 ? '#ffff00' : '#ff8800'}
                        />
                        <DataItem 
                            label="é¢„è®¡" 
                            value={`${Math.round(eta)} ç§’`}
                            color="#ff00ff"
                        />
                    </div>

                    {Math.abs(relativeHeading) > 5 && (
                        <div style={turnAdviceStyle}>
                            {relativeHeading > 0 ? 'â†’ å³è½¬' : 'â† å·¦è½¬'} {Math.abs(Math.round(relativeHeading))}Â°
                        </div>
                    )}

                    {Math.abs(elevationDiff) > 100 && (
                        <div style={altitudeAdviceStyle}>
                            {elevationDiff > 0 ? 'â†‘ çˆ¬å‡' : 'â†“ ä¸‹é™'} {Math.abs(Math.round(elevationDiff))} m
                        </div>
                    )}
                </div>
            )}

            {!showPanel && navigationData && (
                <button 
                    style={minimizedButtonStyle}
                    onClick={() => setShowPanel(true)}
                >
                    ğŸ¯ å¯¼èˆª
                </button>
            )}
        </div>
    );
};

// æ–¹å‘æŒ‡ç¤ºå™¨å­ç»„ä»¶
const DirectionIndicator = ({ relativeHeading, distance }) => {
    return (
        <div style={indicatorStyle}>
            <svg width="120" height="120">
                {/* å¤–åœˆ */}
                <circle 
                    cx="60" 
                    cy="60" 
                    r="55" 
                    fill="none" 
                    stroke="#00ff00" 
                    strokeWidth="2"
                />
                
                {/* åˆ»åº¦ */}
                {[0, 90, 180, 270].map(angle => {
                    const rad = (angle * Math.PI) / 180;
                    const x1 = 60 + Math.cos(rad) * 50;
                    const y1 = 60 + Math.sin(rad) * 50;
                    const x2 = 60 + Math.cos(rad) * 55;
                    const y2 = 60 + Math.sin(rad) * 55;
                    
                    return (
                        <line 
                            key={angle}
                            x1={x1} 
                            y1={y1} 
                            x2={x2} 
                            y2={y2} 
                            stroke="#00ff00" 
                            strokeWidth="2"
                        />
                    );
                })}

                {/* é£æœºç¬¦å·ï¼ˆå§‹ç»ˆæœä¸Šï¼‰ */}
                <g transform="translate(60, 60)">
                    <path 
                        d="M 0,-15 L -8,10 L 8,10 Z" 
                        fill="#ff0000" 
                        stroke="#ffffff" 
                        strokeWidth="2"
                    />
                </g>

                {/* ç›®æ ‡ç®­å¤´ */}
                <g transform={`translate(60, 60) rotate(${relativeHeading})`}>
                    <line 
                        x1="0" 
                        y1="0" 
                        x2="0" 
                        y2="-45" 
                        stroke="#ffff00" 
                        strokeWidth="3"
                        markerEnd="url(#arrowhead)"
                    />
                </g>

                <defs>
                    <marker 
                        id="arrowhead" 
                        markerWidth="10" 
                        markerHeight="10" 
                        refX="5" 
                        refY="3" 
                        orient="auto"
                    >
                        <polygon 
                            points="0 0, 10 3, 0 6" 
                            fill="#ffff00" 
                        />
                    </marker>
                </defs>
            </svg>
            
            <div style={distanceDisplayStyle}>
                {(distance / 1000).toFixed(1)} km
            </div>
        </div>
    );
};

// æ•°æ®é¡¹å­ç»„ä»¶
const DataItem = ({ label, value, color }) => (
    <div style={dataItemStyle}>
        <div style={{ color: '#888', fontSize: '11px' }}>{label}</div>
        <div style={{ color, fontSize: '16px', fontWeight: 'bold' }}>{value}</div>
    </div>
);

const containerStyle = {
    position: 'absolute',
    top: '20px',
    left: '50%',
    transform: 'translateX(-50%)',
    zIndex: 1000,
};

const navPanelStyle = {
    backgroundColor: 'rgba(0, 0, 0, 0.85)',
    border: '2px solid #00ff00',
    borderRadius: '10px',
    padding: '15px',
    minWidth: '320px',
    fontFamily: 'monospace',
};

const headerStyle = {
    display: 'flex',
    justifyContent: 'space-between',
    alignItems: 'center',
    color: '#00ff00',
    fontSize: '16px',
    fontWeight: 'bold',
    marginBottom: '15px',
    paddingBottom: '10px',
    borderBottom: '1px solid #00ff00',
};

const toggleButtonStyle = {
    background: 'none',
    border: '1px solid #00ff00',
    color: '#00ff00',
    cursor: 'pointer',
    padding: '2px 8px',
    borderRadius: '3px',
    fontSize: '14px',
};

const waypointInfoStyle = {
    marginBottom: '15px',
    textAlign: 'center',
};

const waypointNameStyle = {
    color: '#ffff00',
    fontSize: '18px',
    fontWeight: 'bold',
    marginBottom: '5px',
};

const progressStyle = {
    color: '#00ffff',
    fontSize: '12px',
};

const directionIndicatorContainerStyle = {
    display: 'flex',
    justifyContent: 'center',
    marginBottom: '15px',
};

const indicatorStyle = {
    position: 'relative',
};

const distanceDisplayStyle = {
    position: 'absolute',
    top: '50%',
    left: '50%',
    transform: 'translate(-50%, -50%)',
    color: '#ffff00',
    fontSize: '14px',
    fontWeight: 'bold',
    textShadow: '0 0 5px #000',
};

const dataGridStyle = {
    display: 'grid',
    gridTemplateColumns: '1fr 1fr',
    gap: '10px',
    marginBottom: '10px',
};

const dataItemStyle = {
    backgroundColor: 'rgba(0, 50, 0, 0.5)',
    padding: '8px',
    borderRadius: '5px',
    textAlign: 'center',
};

const turnAdviceStyle = {
    backgroundColor: 'rgba(255, 255, 0, 0.2)',
    border: '1px solid #ffff00',
    color: '#ffff00',
    padding: '8px',
    borderRadius: '5px',
    textAlign: 'center',
    fontSize: '14px',
    fontWeight: 'bold',
    marginTop: '10px',
};

const altitudeAdviceStyle = {
    backgroundColor: 'rgba(255, 136, 0, 0.2)',
    border: '1px solid #ff8800',
    color: '#ff8800',
    padding: '8px',
    borderRadius: '5px',
    textAlign: 'center',
    fontSize: '14px',
    fontWeight: 'bold',
    marginTop: '5px',
};

const minimizedButtonStyle = {
    backgroundColor: 'rgba(0, 0, 0, 0.7)',
    border: '2px solid #00ff00',
    color: '#00ff00',
    padding: '10px 20px',
    borderRadius: '5px',
    cursor: 'pointer',
    fontFamily: 'monospace',
    fontSize: '14px',
    fontWeight: 'bold',
};

export default WaypointNavigation;

--- End of File: src/components/WaypointNavigation/index.jsx ---

--- File: src/components/InstrumentPanel/index.jsx ---

// components/InstrumentPanel/index.jsx

import AttitudeIndicator from '../AttitudeIndicator';
import RadarMap from '../RadarMap';
import { LANDMARKS } from '../../config/landmarksConfig';

const InstrumentPanel = ({ flightData, waypoints }) => {
    if (!flightData) return null;

    const { pitch, roll, position, heading } = flightData;

    return (
        <div style={panelContainerStyle}>
            <AttitudeIndicator pitch={pitch} roll={roll} />
            <div style={{ height: '15px' }} />
            <RadarMap 
                position={position} 
                heading={heading}
                landmarks={LANDMARKS}
                waypoints={waypoints}
            />
        </div>
    );
};

const panelContainerStyle = {
    position: 'absolute',
    bottom: '40px',
    left: '20px',
    zIndex: 1000,
    display: 'flex',
    flexDirection: 'column',
    gap: '10px',
};

export default InstrumentPanel;

--- End of File: src/components/InstrumentPanel/index.jsx ---

--- File: src/components/AttitudeIndicator/index.jsx ---

// components/AttitudeIndicator/index.jsx

import { useEffect, useRef } from 'react';
import * as Cesium from 'cesium';

const AttitudeIndicator = ({ pitch, roll }) => {
    const canvasRef = useRef(null);

    useEffect(() => {
        const canvas = canvasRef.current;
        if (!canvas) return;

        const ctx = canvas.getContext('2d');
        const size = 200;
        const centerX = size / 2;
        const centerY = size / 2;

        // æ¸…ç©ºç”»å¸ƒ
        ctx.clearRect(0, 0, size, size);

        // ä¿å­˜å½“å‰çŠ¶æ€
        ctx.save();

        // ç§»åŠ¨åˆ°ä¸­å¿ƒå¹¶åº”ç”¨æ»šè½¬è§’
        ctx.translate(centerX, centerY);
        ctx.rotate(-roll); // è´Ÿå·å› ä¸ºcanvasåæ ‡ç³»

        // ç»˜åˆ¶å¤©ç©ºå’Œåœ°é¢
        const pitchPixels = (Cesium.Math.toDegrees(pitch) / 90) * (size / 2);
        
        // å¤©ç©º
        ctx.fillStyle = '#4a90e2';
        ctx.fillRect(-size, -size, size * 2, size + pitchPixels);
        
        // åœ°é¢
        ctx.fillStyle = '#8b4513';
        ctx.fillRect(-size, pitchPixels, size * 2, size * 2);

        // ç»˜åˆ¶åœ°å¹³çº¿
        ctx.strokeStyle = '#ffffff';
        ctx.lineWidth = 3;
        ctx.beginPath();
        ctx.moveTo(-size, pitchPixels);
        ctx.lineTo(size, pitchPixels);
        ctx.stroke();

        // ç»˜åˆ¶ä¿¯ä»°åˆ»åº¦çº¿
        ctx.strokeStyle = '#ffffff';
        ctx.lineWidth = 2;
        ctx.font = '12px monospace';
        ctx.fillStyle = '#ffffff';
        ctx.textAlign = 'left';
        ctx.textBaseline = 'middle';

        for (let angle = -90; angle <= 90; angle += 10) {
            if (angle === 0) continue;
            const y = pitchPixels - (angle / 90) * (size / 2);
            
            if (Math.abs(y) < size) {
                const lineLength = angle % 30 === 0 ? 40 : 20;
                ctx.beginPath();
                ctx.moveTo(-lineLength / 2, y);
                ctx.lineTo(lineLength / 2, y);
                ctx.stroke();

                if (angle % 30 === 0) {
                    const label = angle > 0 ? `${angle}` : `${-angle}`;
                    const labelX = lineLength / 2;
                    ctx.fillText(label, labelX, y);
                }
            }
        }

        // æ¢å¤çŠ¶æ€
        ctx.restore();

        // ç»˜åˆ¶é£æœºæ ‡å¿—ï¼ˆå›ºå®šåœ¨ä¸­å¿ƒï¼‰
        ctx.strokeStyle = '#ffff00';
        ctx.lineWidth = 3;
        ctx.beginPath();
        // ä¸­å¿ƒç‚¹
        ctx.arc(centerX, centerY, 3, 0, Math.PI * 2);
        ctx.fill();
        // å·¦ç¿¼
        ctx.moveTo(centerX - 60, centerY);
        ctx.lineTo(centerX - 10, centerY);
        // å³ç¿¼
        ctx.moveTo(centerX + 10, centerY);
        ctx.lineTo(centerX + 60, centerY);
        // ä¸­å¿ƒæ¨ªçº¿
        ctx.moveTo(centerX - 10, centerY);
        ctx.lineTo(centerX + 10, centerY);
        ctx.stroke();

        // ç»˜åˆ¶å¤–æ¡†
        ctx.strokeStyle = '#00ff00';
        ctx.lineWidth = 2;
        ctx.strokeRect(2, 2, size - 4, size - 4);

        // ç»˜åˆ¶æ»šè½¬åˆ»åº¦
        ctx.save();
        ctx.translate(centerX, centerY);
        
        // å¤–åœˆåˆ»åº¦
        const radius = size / 2 - 15;
        ctx.strokeStyle = '#00ff00';
        ctx.lineWidth = 2;
        
        for (let angle = 0; angle < 360; angle += 30) {
            const rad = Cesium.Math.toRadians(angle);
            const x1 = Math.cos(rad - Math.PI / 2) * radius;
            const y1 = Math.sin(rad - Math.PI / 2) * radius;
            const length = angle % 90 === 0 ? 10 : 5;
            const x2 = Math.cos(rad - Math.PI / 2) * (radius - length);
            const y2 = Math.sin(rad - Math.PI / 2) * (radius - length);
            
            ctx.beginPath();
            ctx.moveTo(x1, y1);
            ctx.lineTo(x2, y2);
            ctx.stroke();
        }

        // æ»šè½¬æŒ‡ç¤ºä¸‰è§’å½¢
        ctx.fillStyle = '#ffff00';
        ctx.strokeStyle = '#ffff00';
        ctx.lineWidth = 2;
        ctx.save();
        ctx.rotate(-roll);
        ctx.beginPath();
        ctx.moveTo(0, -radius + 5);
        ctx.lineTo(-8, -radius + 15);
        ctx.lineTo(8, -radius + 15);
        ctx.closePath();
        ctx.fill();
        ctx.stroke();
        ctx.restore();

        ctx.restore();

    }, [pitch, roll]);

    return (
        <div style={containerStyle}>
            <div style={labelStyle}>äººå·¥åœ°å¹³ä»ª</div>
            <canvas 
                ref={canvasRef} 
                width={200} 
                height={200}
                style={canvasStyle}
            />
            <div style={infoStyle}>
                <div>ä¿¯ä»°: {Math.round(Cesium.Math.toDegrees(pitch))}Â°</div>
                <div>æ»šè½¬: {Math.round(Cesium.Math.toDegrees(roll))}Â°</div>
            </div>
        </div>
    );
};

const containerStyle = {
    backgroundColor: 'rgba(0, 0, 0, 0.7)',
    padding: '10px',
    borderRadius: '10px',
    border: '2px solid #00ff00',
    display: 'flex',
    flexDirection: 'column',
    alignItems: 'center',
    justifyContent: 'center'
};

const labelStyle = {
    color: '#00ff00',
    fontFamily: 'monospace',
    fontSize: '14px',
    fontWeight: 'bold',
    marginBottom: '5px',
    textAlign: 'center',
};

const canvasStyle = {
    display: 'block',
    border: '1px solid #00ff00',
    borderRadius: '5px',
};

const infoStyle = {
    marginTop: '5px',
    color: '#00ff00',
    fontFamily: 'monospace',
    fontSize: '12px',
    textAlign: 'center',
};

export default AttitudeIndicator;

--- End of File: src/components/AttitudeIndicator/index.jsx ---

--- File: src/config/landmarksConfig.js ---

// config/landmarksConfig.js

export const LANDMARKS = [
    // ä¸­å›½
    { name: 'ä¸Šæµ·ä¸œæ–¹æ˜ç ', longitude: 121.4995, latitude: 31.2397, color: '#ff00ff' },
    { name: 'åŒ—äº¬æ•…å®«', longitude: 116.3972, latitude: 39.9163, color: '#ff00ff' },
    { name: 'é¦™æ¸¯ç»´å¤šåˆ©äºšæ¸¯', longitude: 114.1694, latitude: 22.2783, color: '#ff00ff' },
    { name: 'è¥¿å®‰ç§¦å§‹çš‡å…µé©¬ä¿‘', longitude: 109.2924, latitude: 34.3849, color: '#ff00ff' },
    { name: 'æ‹‰è¨å¸ƒè¾¾æ‹‰å®«', longitude: 91.1175, latitude: 29.6578, color: '#ff00ff' },
    { name: 'å…«è¾¾å²­é•¿åŸ', longitude: 116.0206, latitude: 40.3653, color: '#ff00ff' },

    // äºšæ´²
    { name: 'ä¸œäº¬å¡”', longitude: 139.7454, latitude: 35.6586, color: '#ff8800' },
    { name: 'å°åº¦æ³°å§¬é™µ', longitude: 78.0421, latitude: 27.1751, color: '#ff8800' },
    { name: 'æŸ¬åŸ”å¯¨å´å“¥çªŸ', longitude: 103.8669, latitude: 13.4125, color: '#ff8800' },
    { name: 'æ³°å›½å¤§çš‡å®«', longitude: 100.4920, latitude: 13.7500, color: '#ff8800' },
    { name: 'æ–°åŠ å¡é±¼å°¾ç‹®å…¬å›­', longitude: 103.8520, latitude: 1.2868, color: '#ff8800' },
    { name: 'éŸ©å›½æ™¯ç¦å®«', longitude: 126.9769, latitude: 37.5796, color: '#ff8800' },
    { name: 'é©¬æ¥è¥¿äºšåŒå­å¡”', longitude: 101.6869, latitude: 3.1579, color: '#ff8800' },
    { name: 'å°å°¼å©†ç½—æµ®å± ', longitude: 110.2038, latitude: -7.6079, color: '#ff8800' },
    { name: 'é˜¿è”é…‹å“ˆåˆ©æ³•å¡”', longitude: 55.2744, latitude: 25.1972, color: '#ff8800' },
    { name: 'å°æ¹¾å°åŒ—101', longitude: 121.5645, latitude: 25.0339, color: '#ff8800' },
    { name: 'ç ç©†æœ—ç›å³°(å—å¡)', longitude: 86.9250, latitude: 27.9881, color: '#ff8800' },
    
    // åŒ—ç¾
    { name: 'çº½çº¦è‡ªç”±å¥³ç¥åƒ', longitude: -74.0445, latitude: 40.6892, color: '#ffff00' },
    { name: 'æ—§é‡‘å±±é‡‘é—¨å¤§æ¡¥', longitude: -122.4783, latitude: 37.8199, color: '#ffff00' },
    { name: 'åç››é¡¿ç™½å®«', longitude: -77.0365, latitude: 38.8977, color: '#ffff00' },
    { name: 'æ‹‰æ–¯ç»´åŠ æ–¯å¤§é“', longitude: -115.1728, latitude: 36.1147, color: '#ffff00' },
    { name: 'é»„çŸ³è€å¿ å®æ³‰', longitude: -110.8281, latitude: 44.4605, color: '#ffff00' },
    { name: 'å¤šä¼¦å¤šCNå¡”', longitude: -79.3871, latitude: 43.6426, color: '#ffff00' },
    { name: 'å¢¨è¥¿å“¥å¥‡ç´ä¼Šå¯Ÿ', longitude: -88.5678, latitude: 20.6843, color: '#ffff00' },
    { name: 'ç§‘ç½—æ‹‰å¤šå¤§å³¡è°·(é©¬ç‘Ÿç‚¹)', longitude: -112.1129, latitude: 36.0570, color: '#ffff00' },
    { name: 'ä¼˜èƒœç¾åœ°åŠåœ†ä¸˜', longitude: -119.5332, latitude: 37.7459, color: '#ffff00' },
    
    // æ¬§æ´²
    { name: 'å·´é»åŸƒè²å°”é“å¡”', longitude: 2.2945, latitude: 48.8584, color: '#00ffff' },
    { name: 'ä¼¦æ•¦å¤§æœ¬é’Ÿ', longitude: -0.1246, latitude: 51.5007, color: '#00ffff' },
    { name: 'ç½—é©¬æ–—å…½åœº', longitude: 12.4922, latitude: 41.8902, color: '#00ffff' },
    { name: 'å·´å¡ç½—é‚£åœ£å®¶å ‚', longitude: 2.1744, latitude: 41.4036, color: '#00ffff' },
    { name: 'é›…å…¸å«åŸ', longitude: 23.7257, latitude: 37.9715, color: '#00ffff' },
    { name: 'æŸæ—å‹ƒå…°ç™»å ¡é—¨', longitude: 13.3777, latitude: 52.5163, color: '#00ffff' },
    { name: 'è«æ–¯ç§‘çº¢åœº', longitude: 37.6208, latitude: 55.7540, color: '#00ffff' },
    { name: 'å¸ƒæ‹‰æ ¼æŸ¥ç†å¤§æ¡¥', longitude: 14.4114, latitude: 50.0865, color: '#00ffff' },
    { name: 'å¨å°¼æ–¯åœ£é©¬å¯å¹¿åœº', longitude: 12.3389, latitude: 45.4340, color: '#00ffff' },
    { name: 'æ¢µè’‚å†ˆåœ£å½¼å¾—å¤§æ•™å ‚', longitude: 12.4534, latitude: 41.9022, color: '#00ffff' },
    { name: 'é˜¿å§†æ–¯ç‰¹ä¸¹å›½ç«‹åšç‰©é¦†', longitude: 4.8852, latitude: 52.3600, color: '#00ffff' },
    
    // å—ç¾
    { name: 'é‡Œçº¦çƒ­å†…å¢åŸºç£åƒ', longitude: -43.2105, latitude: -22.9519, color: '#ffaa00' },
    { name: 'ç§˜é²é©¬ä¸˜æ¯”ä¸˜', longitude: -72.5449, latitude: -13.1631, color: '#ffaa00' },
    { name: 'ä¼Šç“œè‹ç€‘å¸ƒ', longitude: -54.4447, latitude: -25.6953, color: '#ffaa00' },
    { name: 'ç»åˆ©ç»´äºšä¹Œå°¤å°¼ç›æ²¼', longitude: -67.4891, latitude: -20.1338, color: '#ffaa00' },
    { name: 'ä½©é‡Œæ‰˜è«é›·è¯ºå†°å·', longitude: -73.0494, latitude: -50.4726, color: '#ffaa00' },

    // éæ´²
    { name: 'åŸƒåŠå‰è¨é‡‘å­—å¡”', longitude: 31.1342, latitude: 29.9792, color: '#00ff88' },
    { name: 'å¦æ¡‘å°¼äºšä¹åŠ›é©¬æ‰ç½—', longitude: 37.3556, latitude: -3.0674, color: '#00ff88' },
    { name: 'å¼€æ™®æ•¦æ¡Œå±±', longitude: 18.4106, latitude: -33.9630, color: '#00ff88' },
    { name: 'é©¬æ‹‰å–€ä»€æ°é©¬å¤«çº³å¹¿åœº', longitude: -7.9880, latitude: 31.6258, color: '#00ff88' },
    { name: 'ç»´å¤šåˆ©äºšç€‘å¸ƒ', longitude: 25.8580, latitude: -17.9243, color: '#00ff88' },

    // ä¸­ä¸œ
    { name: 'çº¦æ—¦ä½©ç‰¹æ‹‰å¤åŸ', longitude: 35.4444, latitude: 30.3285, color: '#ff4444' },
    { name: 'è€¶è·¯æ’’å†·åœ£æ®¿å±±', longitude: 35.2354, latitude: 31.7767, color: '#ff4444' },
    { name: 'éº¦åŠ ç¦å¯º', longitude: 39.8262, latitude: 21.4225, color: '#ff4444' },
    { name: 'ä¼Šæ–¯å¦å¸ƒå°”åœ£ç´¢è²äºšå¤§æ•™å ‚', longitude: 28.9799, latitude: 41.0086, color: '#ff4444' },

    // å¤§æ´‹æ´²
    { name: 'æ‚‰å°¼æ­Œå‰§é™¢', longitude: 151.2153, latitude: -33.8568, color: '#ff8800' },
    { name: 'æ¾³å¤§åˆ©äºšå¤§å ¡ç¤', longitude: 147.6992, latitude: -18.2871, color: '#ff8800' },
    { name: 'æ¾³å¤§åˆ©äºšä¹Œé²é²(å·¨å²©)', longitude: 131.0369, latitude: -25.3444, color: '#ff8800' },
    { name: 'æ–°è¥¿å…°ç±³å°”ç¦å¾·å³¡æ¹¾', longitude: 167.9230, latitude: -44.6760, color: '#ff8800' },
    { name: 'å¥¥å…‹å…°å¤©ç©ºå¡”', longitude: 174.7633, latitude: -36.8485, color: '#ff8800' },
    { name: 'å¤æ´»èŠ‚å²›æ‘©è‰¾çŸ³åƒ', longitude: -109.2760, latitude: -27.1250, color: '#ff8800' },
];

--- End of File: src/config/landmarksConfig.js ---

--- File: src/config/aircraftConfig.js ---

// src/config/aircraftConfig.js

import * as Cesium from 'cesium';

const DEFAULT_ICON = 'assets/plane.png';

export const AIRCRAFT = {
    CESIUM_AIR: {
        id: 'CESIUM_AIR',
        name: 'Cesium Air (é€šç”¨)',
        uri: 'assets/Cesium_Air.glb',
        iconUrl: DEFAULT_ICON,
        scale: 1.0,
        physics: {
            maxSpeed: 300, // m/s (çº¦ 1080 km/h)
            pitchRate: 1.5, // ä¿¯ä»°é€Ÿç‡
            rollRate: 3.0,  // æ»šè½¬é€Ÿç‡
            yawRate: 1.0,   // åèˆªé€Ÿç‡
            stallSpeed: 40, // å¤±é€Ÿé€Ÿåº¦ m/s
        },
    },
    F22: {
        id: 'F-22 Raptor',
        name: 'F-22 Raptor (æˆ˜æ–—æœº)',
        uri: 'assets/f22.glb',
        iconUrl: DEFAULT_ICON,
        scale: 10.0,
        physics: {
            maxSpeed: 650,
            pitchRate: 9.0,
            rollRate: 25.0,
            yawRate: 5.0,
            stallSpeed: 80,
        },
    },
    TIE: {
        id: 'TIE',
        name: 'TIE Fighter (æ˜Ÿé™…æˆ˜æ–—æœº)',
        uri: 'assets/tie.glb',
        iconUrl: DEFAULT_ICON,
        scale: 1.0,
        modelOptions: {
            silhouetteColor : Cesium.Color.WHITE,
            silhouetteSize : 0,
            colorBlendMode:Cesium.ColorBlendMode.MIX,
            colorBlendAmount: 0.1
        },
        physics: {
            maxSpeed: 999,
            pitchRate: 20.0,
            rollRate: 50.0,
            yawRate: 12.0,
            stallSpeed: 75,
        },
    },
};

export const AIRCRAFT_LIST = Object.values(AIRCRAFT);


--- End of File: src/config/aircraftConfig.js ---

--- File: src/helpers/Aircraft.js ---

// src/helpers/Aircraft.js

import * as Cesium from 'cesium';
import { Physics } from './Physics';

const _orientationFixResult = new Cesium.Quaternion();

export class Aircraft {
    constructor(viewer, config, initialPosition, initialHeading = 0, initialOrientation = null) {
        this.viewer = viewer;
        this.config = config;

        const initOrientation = initialOrientation
        ? Cesium.Quaternion.clone(initialOrientation)
        : Cesium.Transforms.headingPitchRollQuaternion(
            initialPosition,
            new Cesium.HeadingPitchRoll(initialHeading, 0, 0)
            );

        this.state = {
        position: initialPosition,
        velocity: new Cesium.Cartesian3(0, 0, 0),
        orientation: initOrientation,
        heading: initialHeading,
        pitch: 0,
        roll: 0,
        speed: 50,
        throttle: 0.5,
        status: { isStalled: false, isSupersonic: false, crashed: false },
        };

        this.entity = this._createEntity();
    }

    _createEntity() {
        return this.viewer.entities.add({
            position: new Cesium.CallbackProperty(() => this.state.position, false),
            
            orientation: new Cesium.CallbackProperty(() => {
                if (this.config.orientationFix) {
                    return Cesium.Quaternion.multiply(
                        this.state.orientation, 
                        this.config.orientationFix, 
                        _orientationFixResult
                    );
                }
                return this.state.orientation;
            }, false),

            model: {
                uri: this.config.uri,
                scale: this.config.scale,
                minimumPixelSize: this.config.minimumPixelSize,
                // ä½¿ç”¨å±•å¼€è¿ç®—ç¬¦(...)å°†modelOptionsä¸­çš„æ‰€æœ‰å±æ€§åº”ç”¨åˆ°è¿™é‡Œ
                ...this.config.modelOptions 
            }
        });
    }

    // æ·»åŠ  terrainHeight å‚æ•°
    update(controls, deltaTime, terrainHeight) {
        if (this.state.status.crashed) return;
        
        // å°† terrainHeight ä¼ é€’ç»™ Physics.update
        const newState = Physics.update(this.state, controls, this.config.physics, deltaTime, terrainHeight);
        this.state = newState;
    }

    destroy() {
        if (this.entity) {
            this.viewer.entities.remove(this.entity);
            this.entity = null;
        }
    }
}

--- End of File: src/helpers/Aircraft.js ---

--- File: src/helpers/InputController.js ---

// src/helpers/InputController.js

export class InputController {
    constructor() {
        this.controls = {
            pitch: 0, // -1 to 1 (S to W)
            roll: 0,  // -1 to 1 (A to D)
            yaw: 0,   // -1 to 1 (Q to E)
            throttle: 0 // -1 to 1 (Ctrl to Shift)
        };
        this.keys = {};
        this._addEventListeners();
    }

    _addEventListeners() {
        this._onKeyDown = (e) => this._handleKeyEvent(e, true);
        this._onKeyUp   = (e) => this._handleKeyEvent(e, false);
        window.addEventListener('keydown', this._onKeyDown);
        window.addEventListener('keyup', this._onKeyUp);
    }

    _handleKeyEvent(e, isPressed) {
        this.keys[e.key.toLowerCase()] = isPressed;
        this._updateControls();
    }

    _updateControls() {
        this.controls.pitch = (this.keys['w'] ? 1 : 0) + (this.keys['s'] ? -1 : 0);
        this.controls.roll = (this.keys['a'] ? -1 : 0) + (this.keys['d'] ? 1 : 0);
        this.controls.yaw = (this.keys['q'] ? -1 : 0) + (this.keys['e'] ? 1 : 0);
        this.controls.throttle = (this.keys['shift'] ? 1 : 0) + (this.keys['control'] ? -1 : 0);
    }
    
    destroy() {
        window.removeEventListener('keydown', this._onKeyDown);
        window.removeEventListener('keyup', this._onKeyUp);
    }
}

--- End of File: src/helpers/InputController.js ---

--- File: src/helpers/CameraController.js ---

// src/helpers/CameraController.js

import * as Cesium from 'cesium';

export class CameraController {
    constructor(viewer) {
        this.viewer = viewer;
        this.aircraft = null; 
        
        // FLIGHT æ¨¡å¼ç›¸æœºæ§åˆ¶ç›¸å…³
        this.isUserControlling = false;
        this.userCameraOffset = { heading: 0, pitch: 0, distance: 50 };
        this.defaultCameraOffset = { heading: 0, pitch: 0, distance: 10, height: 2 };
        this.resetTimer = null;
        this.resetDelay = 2000; // 2ç§’æ— æ“ä½œåè‡ªåŠ¨å›æ­£
        this.isResetting = false;
        this.resetDuration = 1000; // å›æ­£åŠ¨ç”»æ—¶é•¿(æ¯«ç§’)
        this.resetStartTime = null;
        this.resetStartOffset = null;
        
        // é¼ æ ‡æ‹–æ‹½çŠ¶æ€
        this.isDragging = false;
        this.lastMousePosition = null;
        
        this._setupFlightModeControls();
        this.exitGlobalView();
    }

    setTarget(aircraftInstance) {
        this.aircraft = aircraftInstance;
    }

    _setupFlightModeControls() {
        // ä½¿ç”¨ Cesium çš„ ScreenSpaceEventHandler
        this.handler = new Cesium.ScreenSpaceEventHandler(this.viewer.scene.canvas);
        
        // å·¦é”®æŒ‰ä¸‹
        this.handler.setInputAction((movement) => {
            this.isDragging = true;
            this.lastMousePosition = { 
                x: movement.position.x, 
                y: movement.position.y 
            };
            this.isUserControlling = true;
            this._clearResetTimer();
            this.isResetting = false;
        }, Cesium.ScreenSpaceEventType.LEFT_DOWN);
        
        // é¼ æ ‡ç§»åŠ¨
        this.handler.setInputAction((movement) => {
            if (!this.isDragging || !this.lastMousePosition) return;
            
            const deltaX = movement.endPosition.x - this.lastMousePosition.x;
            const deltaY = movement.endPosition.y - this.lastMousePosition.y;
            
            // æ›´æ–°ç›¸æœºåç§»ï¼ˆå¢åŠ çµæ•åº¦ï¼‰
            this.userCameraOffset.heading -= deltaX * 0.01;
            this.userCameraOffset.pitch += deltaY * 0.01;
            
            // é™åˆ¶ä¿¯ä»°è§’èŒƒå›´
            this.userCameraOffset.pitch = Math.max(-Math.PI / 2, Math.min(Math.PI / 2, this.userCameraOffset.pitch));
            
            this.lastMousePosition = { 
                x: movement.endPosition.x, 
                y: movement.endPosition.y 
            };
        }, Cesium.ScreenSpaceEventType.MOUSE_MOVE);
        
        // å·¦é”®æ¾å¼€
        this.handler.setInputAction(() => {
            if (this.isDragging) {
                this.isDragging = false;
                this.lastMousePosition = null;
                this._startResetTimer();
            }
        }, Cesium.ScreenSpaceEventType.LEFT_UP);
        
        // æ»šè½®ç¼©æ”¾ - ä¸è§¦å‘å›æ­£
        this.handler.setInputAction((wheelDelta) => {
            // wheelDelta æ˜¯æ­£æ•°è¡¨ç¤ºå‘ä¸Šæ»šï¼Œè´Ÿæ•°è¡¨ç¤ºå‘ä¸‹æ»š
            this.userCameraOffset.distance += wheelDelta * -0.08;
            this.userCameraOffset.distance = Math.max(20, Math.min(200, this.userCameraOffset.distance));
        }, Cesium.ScreenSpaceEventType.WHEEL);
    }

    _startResetTimer() {
        this._clearResetTimer();
        this.resetTimer = setTimeout(() => {
            this._startResetAnimation();
        }, this.resetDelay);
    }

    _clearResetTimer() {
        if (this.resetTimer) {
            clearTimeout(this.resetTimer);
            this.resetTimer = null;
        }
    }

    _startResetAnimation() {
        this.isResetting = true;
        this.resetStartTime = Date.now();
        // åªè®°å½• heading å’Œ pitchï¼Œä¸åŒ…æ‹¬ distance
        this.resetStartOffset = { 
            heading: this.userCameraOffset.heading,
            pitch: this.userCameraOffset.pitch,
            distance: this.userCameraOffset.distance // ä¿æŒå½“å‰è·ç¦»ä¸å˜
        };
    }

    _updateResetAnimation() {
        if (!this.isResetting) return;
        
        const elapsed = Date.now() - this.resetStartTime;
        const progress = Math.min(1, elapsed / this.resetDuration);
        
        // ä½¿ç”¨ç¼“åŠ¨å‡½æ•°ï¼ˆease-outï¼‰
        const eased = 1 - Math.pow(1 - progress, 3);
        
        // åªæ’å€¼ heading å’Œ pitchï¼Œè·ç¦»ä¿æŒä¸å˜
        this.userCameraOffset.heading = Cesium.Math.lerp(
            this.resetStartOffset.heading, 
            this.defaultCameraOffset.heading, 
            eased
        );
        this.userCameraOffset.pitch = Cesium.Math.lerp(
            this.resetStartOffset.pitch, 
            this.defaultCameraOffset.pitch, 
            eased
        );
        // distance ä¸å˜ï¼Œä¿æŒç”¨æˆ·è®¾ç½®çš„å€¼
        
        if (progress >= 1) {
            this.isResetting = false;
            this.isUserControlling = false;
        }
    }

    animateToGlobalView() {
        if (!this.aircraft) return;

        this.viewer.camera.cancelFlight();

        const currentAircraftPosition = this.aircraft.state.position;
        const directionVector = Cesium.Cartesian3.normalize(currentAircraftPosition, new Cesium.Cartesian3());
        const destinationMagnitude = Cesium.Ellipsoid.WGS84.maximumRadius * 3.0;
        const destination = Cesium.Cartesian3.multiplyByScalar(directionVector, destinationMagnitude, new Cesium.Cartesian3());

        this.viewer.camera.lookDown(Cesium.Math.toRadians(90.0));

        this.viewer.camera.flyTo({
            destination: destination,
            duration: 5.5,
            complete: () => {
                this.enterGlobalView();
            },
        });
    }

    enterGlobalView() {
        this._clearResetTimer();
        this.isResetting = false;
        this.isDragging = false;
        
        // åœ¨å…¨å±€è§†å›¾æ¨¡å¼ä¸‹ï¼Œç¦ç”¨è‡ªå®šä¹‰ handler
        if (this.handler) {
            this.handler.removeInputAction(Cesium.ScreenSpaceEventType.LEFT_DOWN);
            this.handler.removeInputAction(Cesium.ScreenSpaceEventType.MOUSE_MOVE);
            this.handler.removeInputAction(Cesium.ScreenSpaceEventType.LEFT_UP);
            this.handler.removeInputAction(Cesium.ScreenSpaceEventType.WHEEL);
        }
        
        this.viewer.scene.screenSpaceCameraController.enableRotate = true;
        this.viewer.scene.screenSpaceCameraController.enableTranslate = false;
        this.viewer.scene.screenSpaceCameraController.enableZoom = true;
        this.viewer.scene.screenSpaceCameraController.enableTilt = false;
        this.viewer.scene.screenSpaceCameraController.enableLook = true;
    }

    exitGlobalView() {
        this.viewer.camera.cancelFlight();
        
        // é‡ç½®ç”¨æˆ·ç›¸æœºåç§»ï¼ˆä½†ä¿ç•™ç”¨æˆ·è°ƒæ•´çš„è·ç¦»ï¼‰
        const currentDistance = this.userCameraOffset.distance;
        this.userCameraOffset = { ...this.defaultCameraOffset };
        this.userCameraOffset.distance = currentDistance; // ä¿ç•™ç”¨æˆ·è®¾ç½®çš„è·ç¦»
        
        this.isUserControlling = false;
        this.isResetting = false;
        this.isDragging = false;
        this._clearResetTimer();
        
        // é‡æ–°å¯ç”¨è‡ªå®šä¹‰æ§åˆ¶
        this._setupFlightModeControls();
        
        this.viewer.scene.screenSpaceCameraController.enableRotate = false;
        this.viewer.scene.screenSpaceCameraController.enableTranslate = false;
        this.viewer.scene.screenSpaceCameraController.enableZoom = false;
        this.viewer.scene.screenSpaceCameraController.enableTilt = false;
        this.viewer.scene.screenSpaceCameraController.enableLook = false;
    }

    update() {
        if (!this.aircraft || !this.aircraft.state) return;
        
        // æ›´æ–°å›æ­£åŠ¨ç”»
        if (this.isResetting) {
            this._updateResetAnimation();
        }
        
        const { position, orientation } = this.aircraft.state;
        
        // ä½¿ç”¨ç”¨æˆ·æ§åˆ¶çš„åç§»é‡
        const distance = this.userCameraOffset.distance;
        const height = this.defaultCameraOffset.height;
        
        const rotationMatrix = Cesium.Matrix3.fromQuaternion(orientation);
        
        // åº”ç”¨ç”¨æˆ·çš„èˆªå‘å’Œä¿¯ä»°åç§»
        const headingOffset = this.userCameraOffset.heading;
        const pitchOffset = this.userCameraOffset.pitch;
        
        // åŸºç¡€åç§»å‘é‡ï¼ˆç›¸æœºåœ¨é£æœºåæ–¹ï¼‰
        let offset = new Cesium.Cartesian3(-distance, 0, height);
        
        // åº”ç”¨ä¿¯ä»°åç§»ï¼ˆç»•Yè½´æ—‹è½¬ï¼‰
        const pitchRotation = Cesium.Matrix3.fromRotationY(pitchOffset);
        Cesium.Matrix3.multiplyByVector(pitchRotation, offset, offset);
        
        // åº”ç”¨èˆªå‘åç§»ï¼ˆç»•Zè½´æ—‹è½¬ï¼‰
        const headingRotation = Cesium.Matrix3.fromRotationZ(headingOffset);
        Cesium.Matrix3.multiplyByVector(headingRotation, offset, offset);
        
        // åº”ç”¨é£æœºå§¿æ€
        const cameraOffset = Cesium.Matrix3.multiplyByVector(rotationMatrix, offset, new Cesium.Cartesian3());
        const cameraPosition = Cesium.Cartesian3.add(position, cameraOffset, new Cesium.Cartesian3());

        const cameraDirection = Cesium.Cartesian3.normalize(
            Cesium.Cartesian3.subtract(position, cameraPosition, new Cesium.Cartesian3()),
            new Cesium.Cartesian3()
        );

        const cameraUp = Cesium.Matrix3.getColumn(rotationMatrix, 2, new Cesium.Cartesian3());

        this.viewer.camera.setView({
            destination: cameraPosition,
            orientation: {
                direction: cameraDirection,
                up: cameraUp
            }
        });
    }

    destroy() {
        this._clearResetTimer();
        
        // æ¸…ç†äº‹ä»¶å¤„ç†å™¨
        if (this.handler) {
            this.handler.destroy();
            this.handler = null;
        }
        
        this.enterGlobalView();
    }
}

--- End of File: src/helpers/CameraController.js ---

--- File: src/helpers/FlightSimulator.js ---

// helpers/FlightSimulator.js

import * as Cesium from 'cesium';
import { InputController } from './InputController';
import { Aircraft } from './Aircraft';
import { CameraController } from './CameraController';
import { AudioManager } from './AudioManager';

class EventEmitter {
    constructor() { this.events = {}; }
    on(event, listener) {
        if (!this.events[event]) this.events[event] = [];
        this.events[event].push(listener);
    }
    emit(event, payload) {
        if (this.events[event]) {
            this.events[event].forEach(listener => listener(payload));
        }
    }
}

export class FlightSimulator extends EventEmitter {
    constructor(viewer, waypointManager = null) {
        super();
        this.viewer = viewer;
        this.isRunning = false;
        this.viewMode = 'FLIGHT';
        this.audioUnlocked = false;

        this.inputController = new InputController();
        this.cameraController = new CameraController(viewer);
        this.audioManager = new AudioManager();
        this.waypointManager = waypointManager;
        
        this.currentAircraft = null;
        this.aircraftIcon = null;
        this._lastTime = null;
        this._updateLoop = this._updateLoop.bind(this);

        this.terrainProvider = viewer.terrainProvider; // å­˜å‚¨åœ°å½¢æä¾›è€…ä»¥ä¾¿é‡ç”¨

        this._loadAudioFiles();
    }

    /**
     * ä¸ºä¸€ç»„ Cartographic åæ ‡æŸ¥è¯¢å¹¶æ›´æ–°å…¶åœ°å½¢é«˜åº¦
     * @param {Cesium.Cartographic[]} cartographics - å¾…æŸ¥è¯¢çš„åæ ‡æ•°ç»„
     * @returns {Promise<Cesium.Cartographic[]>} - è¿”å›å¸¦æœ‰ç²¾ç¡®åœ°å½¢é«˜åº¦çš„åæ ‡æ•°ç»„
     */
    async getUpdatedCartographicsWithTerrainHeight(cartographics) {
        if (!this.terrainProvider || !Cesium.defined(this.terrainProvider.availability)) {
            console.warn("Terrain provider not available.");
            return cartographics;
        }
        try {
            return await Cesium.sampleTerrainMostDetailed(this.terrainProvider, cartographics);
        } catch (error) {
            console.error("Error sampling terrain height:", error);
            return cartographics;
        }
    }

    async _loadAudioFiles() {
        try {
            await this.audioManager.loadSound('engine', 'assets/engine.wav');
            await this.audioManager.loadSound('sonic-boom', 'assets/warning.wav');
            await this.audioManager.loadSound('stall-warning', 'assets/warning.wav');
            await this.audioManager.loadSound('crash', 'assets/man.wav');


            console.log('Audio files loaded successfully');
            
            this.emit('audioLoaded');
        } catch (error) {
            console.warn('Failed to load some audio files:', error);
        }
    }

    setViewMode(mode) {
        if (this.viewMode === mode) return;
        this.viewMode = mode;
        if (mode === 'GLOBAL') {
            this.currentAircraft.entity.show = false;
            this.aircraftIcon.show = true;
            this.cameraController.animateToGlobalView();
        } else {
            this.currentAircraft.entity.show = true;
            this.aircraftIcon.show = false;
            this.cameraController.exitGlobalView();
        }
    }

    async relocateAircraft(groundPosition) {
        if (!this.currentAircraft) return;

        const cartographic = Cesium.Cartographic.fromCartesian(groundPosition);
        
        const [updatedCartographic] = await this.getUpdatedCartographicsWithTerrainHeight([cartographic]);
        
        // è®¾ç½®é«˜åº¦ä¸ºåœ°å½¢ä¸Šæ–¹1500ç±³
        updatedCartographic.height += 1500;
        const newPosition = Cesium.Cartographic.toCartesian(updatedCartographic);

        this.currentAircraft.state.position = newPosition;
        const hpr = new Cesium.HeadingPitchRoll(this.currentAircraft.state.heading, 0, 0);
        this.currentAircraft.state.orientation = Cesium.Transforms.headingPitchRollQuaternion(newPosition, hpr);
        this.currentAircraft.state.speed = 150;
        this.currentAircraft.state.velocity = new Cesium.Cartesian3(0, 0, 0);
        this.setViewMode('FLIGHT');
    }

    loadAircraft(aircraftConfig, position, heading, orientation) {
        if (this.currentAircraft) {
            this.currentAircraft.destroy();
        }
        if (this.aircraftIcon) {
            this.viewer.entities.remove(this.aircraftIcon);
            this.aircraftIcon = null;
        }
        this.currentAircraft = new Aircraft(this.viewer, aircraftConfig, position, heading, orientation);
        this.cameraController.setTarget(this.currentAircraft);

        this.aircraftIcon = this.viewer.entities.add({
            position: new Cesium.CallbackProperty(() => {
                if (this.currentAircraft) {
                    return this.currentAircraft.state.position;
                }
            }, false),
            billboard: {
                image: aircraftConfig.iconUrl,
                width: 48,
                height: 48,
                disableDepthTestDistance: Number.POSITIVE_INFINITY,
                color: Cesium.Color.WHITE.withAlpha(1.0)
            },
            show: (this.viewMode === 'GLOBAL')
        });

        this.currentAircraft.entity.show = (this.viewMode !== 'GLOBAL');
    }

    async unlockAudio() {
        if (this.audioUnlocked) return;
        const success = await this.audioManager.unlock();
        if (success) {
            this.audioUnlocked = true;
            this.emit('audioUnlocked');
        }
    }

    start() {
        if (this.isRunning) return;
        this.viewer.scene.preUpdate.addEventListener(this._updateLoop);
        this.isRunning = true;
        
        if (this.audioUnlocked) {
            this.audioManager.play('engine', { loop: true, volume: 1.0 });
        }
    }

    stop() {
        if (!this.isRunning) return;
        this.viewer.scene.preUpdate.removeEventListener(this._updateLoop);
        this.isRunning = false;
        
        this.audioManager.stopAll();
    }

    async _updateLoop() {
        const deltaTime = this.viewer.clock.multiplier / 60.0;
        if (!this.currentAircraft) return;

        // 0. è·å–åœ°å½¢é«˜åº¦
        const aircraftCartographic = Cesium.Cartographic.fromCartesian(this.currentAircraft.state.position);
        const [updatedAircraftCartographic] = await this.getUpdatedCartographicsWithTerrainHeight([aircraftCartographic]);
        const terrainHeight = updatedAircraftCartographic?.height ?? 0;
        
        const prevStatus = { ...this.currentAircraft.state.status };

        // 1. æ›´æ–°é£æœºç‰©ç†ï¼Œä¼ å…¥åœ°å½¢é«˜åº¦
        this.currentAircraft.update(this.inputController.controls, deltaTime, terrainHeight);

        // 1.5. æ›´æ–°èˆªç‚¹å¯¼èˆª
        let navData = null;
        if (this.waypointManager && this.waypointManager.isNavigating) {
            navData = this.waypointManager.update(this.currentAircraft.state.position);
        }
        
        const currentStatus = this.currentAircraft.state.status;
        const { speed } = this.currentAircraft.state;
        const { maxSpeed, stallSpeed } = this.currentAircraft.config.physics;

        // 2. æ›´æ–°éŸ³æ•ˆ
        this._updateAudio(prevStatus, currentStatus, speed, maxSpeed, stallSpeed);

        // 3. æ›´æ–°ç›¸æœº (ä»…åœ¨é£è¡Œæ¨¡å¼ä¸‹)
        if (this.viewMode === 'FLIGHT') {
            this.cameraController.update();
        }

        // 4. å‘å°„æ•°æ®æ›´æ–°äº‹ä»¶
        this.emit('flightDataUpdate', {
            ...this.currentAircraft.state,
            navigationData: navData,
        });
    }

    _updateAudio(prevStatus, currentStatus, speed, maxSpeed, stallSpeed) {
        if (currentStatus.isCrashed && !prevStatus.isCrashed) {
            this.audioManager.stopAll();
            this.audioManager.playOneShot('crash', { volume: 1.0 });
            return;
        }

        if (!currentStatus.isCrashed && prevStatus.isCrashed) {
            if (this.audioUnlocked) {
                this.audioManager.play('engine', { loop: true, volume: 1.0 });
            }
        }

        if (currentStatus.isCrashed) return;

        if (this.audioUnlocked) {
            this.audioManager.updateEngineSound(speed, maxSpeed, stallSpeed);
        }

        if (currentStatus.isStalled && !prevStatus.isStalled) {
            this.audioManager.play('stall-warning', { loop: true, volume: 0.3 });
        } else if (!currentStatus.isStalled && prevStatus.isStalled) {
            this.audioManager.stop('stall-warning');
        }

        if (currentStatus.isSupersonic && !prevStatus.isSupersonic) {
            this.audioManager.playOneShot('sonic-boom', { volume: 0.3 });
        }
    }

    destroy() {
        this.stop();
        this.inputController.destroy();
        this.cameraController.destroy();
        this.audioManager.destroy();
        if (this.currentAircraft) {
            this.currentAircraft.destroy();
        }
        if (this.aircraftIcon) {
            this.viewer.entities.remove(this.aircraftIcon);
            this.aircraftIcon = null;
        }
    }
}

--- End of File: src/helpers/FlightSimulator.js ---

--- File: src/helpers/Physics.js ---

// src/helpers/Physics.js


/* 
    è¿™ä¸ªé£è¡Œç‰©ç†å®é™…ä¸Šå¹¶ä¸æ€ä¹ˆæ ·
    åªæ˜¯ä¸€ä¸ªéå¸¸ç®€åŒ–çš„æ¨¡å‹ï¼Œç”¨äºæ¼”ç¤ºç›®çš„
    åç»­æœ‰å¾…ä¼˜åŒ–
*/


import * as Cesium from 'cesium';

const GRAVITY = 9.8; // m/s^2
const MACH_1_SPEED = 343; // ä¸€å€éŸ³é€Ÿ m/s

// å®šä¹‰ä¸€ä¸ªå®‰å…¨é«˜åº¦é˜ˆå€¼ï¼Œè¡¨ç¤ºé£æœºæ¨¡å‹åº•éƒ¨åˆ°ä¸­å¿ƒçš„è·ç¦»ï¼Œé¿å…æœºè…¹â€œè§¦åœ°â€
const CRASH_ALTITUDE_THRESHOLD = 2.0; // 2ç±³

export class Physics {
    
    /**
     * æ›´æ–°é£è¡Œå™¨çŠ¶æ€
     * @param {object} aircraftState - å½“å‰é£è¡Œå™¨çŠ¶æ€
     * @param {object} controls - å½“å‰æ§åˆ¶è¾“å…¥
     * @param {object} physicsParams - é£è¡Œå™¨çš„ç‰©ç†å‚æ•°
     * @param {number} deltaTime - æ—¶é—´å¢é‡ (ç§’)
     * @param {number} terrainHeight - é£æœºæ­£ä¸‹æ–¹çš„åœ°å½¢é«˜åº¦
     * @returns {object} - æ›´æ–°åçš„é£è¡Œå™¨çŠ¶æ€
     */
    static update(aircraftState, controls, physicsParams, deltaTime, terrainHeight) {
        // è§£æ„å½“å‰çŠ¶æ€
        let { position, orientation, speed, throttle, status } = aircraftState;
        const { maxSpeed, pitchRate, rollRate, yawRate, stallSpeed } = physicsParams;

        // 1. æ›´æ–°æ²¹é—¨å’Œé€Ÿåº¦
        throttle = Math.max(0, Math.min(1, throttle + controls.throttle * deltaTime * 0.5));
        const targetSpeed = throttle * maxSpeed;
        speed += (targetSpeed - speed) * deltaTime * 0.8;

        // è§’é€Ÿåº¦ -> å¢é‡è§’
        const pitchAngle = Cesium.Math.toRadians(controls.pitch * pitchRate) * deltaTime;
        const rollAngle  = Cesium.Math.toRadians(controls.roll  * rollRate)  * deltaTime;
        const yawAngle   = Cesium.Math.toRadians(controls.yaw   * yawRate)   * deltaTime;

        // æŒ‰â€œæœºä½“åæ ‡ç³»â€å¢é‡æ—‹è½¬ï¼šä¿æŒ pitch ä¸ºè´Ÿå·ï¼ˆW æŠ¬å¤´ï¼‰
        // å»æ‰ roll/yaw çš„è´Ÿå·ä»¥ç¬¦åˆ A å·¦æ»š / D å³æ»šã€Q å·¦è½¬ / E å³è½¬çš„ç›´è§‰
        const deltaPitch = Cesium.Quaternion.fromAxisAngle(Cesium.Cartesian3.UNIT_Y, pitchAngle);
        const deltaRoll  = Cesium.Quaternion.fromAxisAngle(Cesium.Cartesian3.UNIT_X,  rollAngle);
        const deltaYaw   = Cesium.Quaternion.fromAxisAngle(Cesium.Cartesian3.UNIT_Z, -yawAngle);

        // åˆå¹¶å¢é‡ï¼ˆyaw -> pitch -> rollï¼‰
        let deltaRotation = new Cesium.Quaternion();
        Cesium.Quaternion.multiply(deltaYaw, deltaPitch, deltaRotation);
        Cesium.Quaternion.multiply(deltaRotation, deltaRoll, deltaRotation);

        // å°†å¢é‡åº”ç”¨åˆ°ç°æœ‰å§¿æ€ï¼ˆå³ä¹˜ = æœºä½“åæ ‡ç³»æ—‹è½¬ï¼‰
        Cesium.Quaternion.multiply(orientation, deltaRotation, orientation);
        Cesium.Quaternion.normalize(orientation, orientation);


        // 4. ä»æ–°çš„å§¿æ€å››å…ƒæ•°ä¸­è·å–æœºä½“åæ ‡ç³»å‘é‡
        const rotationMatrix = Cesium.Matrix3.fromQuaternion(orientation);
        const forward = Cesium.Matrix3.getColumn(rotationMatrix, 0, new Cesium.Cartesian3());
        const right = Cesium.Matrix3.getColumn(rotationMatrix, 1, new Cesium.Cartesian3());
        const up = Cesium.Matrix3.getColumn(rotationMatrix, 2, new Cesium.Cartesian3());

        // 5. ç®€åŒ–çš„å‡åŠ›å’Œé‡åŠ›æ¨¡å‹
        // ä¸–ç•Œåæ ‡ç³»çš„ä¸Šæ–¹å‘ (ç”¨äºè®¡ç®—é‡åŠ›)
        const worldUp = Cesium.Cartesian3.normalize(position, new Cesium.Cartesian3());

        const upDot = Math.max(0, Cesium.Cartesian3.dot(up, worldUp)); // æœºä½“â€œä¸Šâ€ä¸ä¸–ç•Œâ€œä¸Šâ€çš„å¯¹é½ç¨‹åº¦
        const liftFactor = Math.min(1, Math.pow(speed / stallSpeed, 2)); // å‡åŠ›ä¸è¶…è¿‡é‡åŠ›
        const liftMagnitude = GRAVITY * liftFactor * upDot;

        const liftForce = Cesium.Cartesian3.multiplyByScalar(up, liftMagnitude, new Cesium.Cartesian3());
        const gravityForce = Cesium.Cartesian3.multiplyByScalar(worldUp, -GRAVITY, new Cesium.Cartesian3());


        // 6. è®¡ç®—æœ€ç»ˆé€Ÿåº¦å‘é‡å¹¶æ›´æ–°ä½ç½®
        const thrustForce = Cesium.Cartesian3.multiplyByScalar(forward, speed, new Cesium.Cartesian3());
        
        // å°†æ‰€æœ‰åŠ›/é€Ÿåº¦åˆæˆ
        let velocity = new Cesium.Cartesian3();
        Cesium.Cartesian3.add(thrustForce, liftForce, velocity);
        Cesium.Cartesian3.add(velocity, gravityForce, velocity);
        
        const movement = Cesium.Cartesian3.multiplyByScalar(velocity, deltaTime, new Cesium.Cartesian3());
        position = Cesium.Cartesian3.add(position, movement, new Cesium.Cartesian3());
        
        // 7. åŸºäºåœ°å½¢çš„ç¢°æ’æ£€æµ‹
        const cartographic = Cesium.Cartographic.fromCartesian(position);
        const altitudeAboveGround = cartographic.height - terrainHeight;

        let hasCrashed = false;
        if (altitudeAboveGround < CRASH_ALTITUDE_THRESHOLD) {
            hasCrashed = true;
            // å æ¯åï¼Œå°†é£æœºä½ç½®å›ºå®šåœ¨åœ°å½¢è¡¨é¢ä¸Š
            cartographic.height = terrainHeight + CRASH_ALTITUDE_THRESHOLD;
            position = Cesium.Cartographic.toCartesian(cartographic);
            speed *= 0.8; // ç¢°æ’åå‡é€Ÿ
        }
        
        // 8. æ›´æ–°çŠ¶æ€ (éŸ³éšœç­‰)
        status.isCrashed = hasCrashed;
        status.isStalled = speed < stallSpeed;
        status.isSupersonic = speed > MACH_1_SPEED;

        // 9. ä»æœ€ç»ˆçš„å››å…ƒæ•°åå‘è®¡ç®—å‡ºHPRï¼Œä»…ç”¨äºUIæ˜¾ç¤º
        // 9. ä½¿ç”¨å½“å‰ä½ç½®çš„ ENU ä½œä¸ºå‚è€ƒç³»è®¡ç®— HPRï¼ˆç”¨äº UIï¼‰
        const enuTransform = Cesium.Transforms.eastNorthUpToFixedFrame(position);
        const enuRotation = Cesium.Matrix4.getMatrix3(enuTransform, new Cesium.Matrix3());
        // æ­£äº¤çŸ©é˜µçš„é€† = è½¬ç½®
        const enuRotationInv = Cesium.Matrix3.transpose(enuRotation, new Cesium.Matrix3());

        const bodyRotation = Cesium.Matrix3.fromQuaternion(orientation);
        const localRotation = Cesium.Matrix3.multiply(enuRotationInv, bodyRotation, new Cesium.Matrix3());
        const localQuat = Cesium.Quaternion.fromRotationMatrix(localRotation);

        const hpr = Cesium.HeadingPitchRoll.fromQuaternion(localQuat);

        
        // è¿”å›åŒ…å«å…¨æ–°å§¿æ€å››å…ƒæ•°çš„æ–°çŠ¶æ€å¯¹è±¡
        return {
            position,
            velocity,
            orientation,
            heading: hpr.heading,
            pitch: hpr.pitch,
            roll: hpr.roll,
            speed,
            throttle,
            status,
        };
    }
}

--- End of File: src/helpers/Physics.js ---

--- File: src/helpers/WaypointManager.js ---

// helpers/WaypointManager.js

import * as Cesium from 'cesium';
import { CoordinateConverter } from './CoordinateConverter';

class EventEmitter {
    constructor() { this.events = {}; }
    on(event, listener) {
        if (!this.events[event]) this.events[event] = [];
        this.events[event].push(listener);
    }
    emit(event, payload) {
        if (this.events[event]) {
            this.events[event].forEach(listener => listener(payload));
        }
    }
    off(event, listener) {
        if (!this.events[event]) return;
        this.events[event] = this.events[event].filter(l => l !== listener);
    }
}

export class WaypointManager extends EventEmitter {
    constructor(viewer) {
        super();
        this.viewer = viewer;
        this.terrainProvider = viewer.terrainProvider; // å­˜å‚¨åœ°å½¢æä¾›è€…
        this.waypoints = [];
        this.currentWaypointIndex = 0;
        this.waypointEntities = [];
        this.pathEntity = null;
        this.completionRadius = 500;
        this.isNavigating = false;
        
        this.aircraftToFirstWaypointPathEntity = null;
        this.lastAircraftPosition = null;
    }

    async _getTerrainHeightForPosition(longitude, latitude) {
        if (!this.terrainProvider || !Cesium.defined(this.terrainProvider.availability)) {
            return 0; // è‹¥æ— åœ°å½¢æœåŠ¡åˆ™è¿”å›0
        }
        const cartographicPosition = Cesium.Cartographic.fromDegrees(longitude, latitude, 0);
        try {
            const updatedPositions = await Cesium.sampleTerrainMostDetailed(this.terrainProvider, [cartographicPosition]);
            return updatedPositions[0]?.height ?? 0;
        } catch (error) {
            console.error("Error sampling waypoint terrain height:", error);
            return 0;
        }
    }

    async addWaypoint(longitude, latitude, aglAltitude, name) {
        const terrainHeight = await this._getTerrainHeightForPosition(longitude, latitude);
        const absoluteAltitude = terrainHeight + aglAltitude;

        const waypoint = {
            id: `waypoint_${Date.now()}_${Math.random()}`,
            name: name || `èˆªç‚¹ ${this.waypoints.length + 1}`,
            position: Cesium.Cartesian3.fromDegrees(longitude, latitude, absoluteAltitude),
            longitude,
            latitude,
            altitude: absoluteAltitude, // å­˜å‚¨ç»å¯¹é«˜åº¦
            reached: false,
            reachedTime: null
        };

        this.waypoints.push(waypoint);
        this._createWaypointEntity(waypoint);
        this._updatePathLine();
        
        this.emit('waypointAdded', waypoint);
        return waypoint;
    }

    async addWaypointFromLandmark(landmark, altitude = 1000) {
        // æ­¤å¤„çš„ 'altitude' è¢«è§†ä¸ºå¯¹åœ°é«˜åº¦ (AGL)
        return await this.addWaypoint(
            landmark.longitude,
            landmark.latitude,
            altitude,
            landmark.name
        );
    }

    _createWaypointEntity(waypoint) {
        const entity = this.viewer.entities.add({
            id: waypoint.id,
            position: waypoint.position,
            ellipsoid: {
                radii: new Cesium.Cartesian3(this.completionRadius, this.completionRadius, this.completionRadius),
                material: Cesium.Color.YELLOW.withAlpha(0.2),
                outline: true,
                outlineColor: Cesium.Color.YELLOW,
                stackPartitions: 24,
                slicePartitions: 24,
                subdivisions: 64
            },
            label: {
                text: waypoint.name,
                font: '16px monospace',
                fillColor: Cesium.Color.YELLOW,
                outlineColor: Cesium.Color.BLACK,
                outlineWidth: 2,
                style: Cesium.LabelStyle.FILL_AND_OUTLINE,
                verticalOrigin: Cesium.VerticalOrigin.BOTTOM,
                pixelOffset: new Cesium.Cartesian2(0, -25),
                disableDepthTestDistance: Number.POSITIVE_INFINITY
            },
            point: {
                pixelSize: 15,
                color: Cesium.Color.YELLOW,
                outlineColor: Cesium.Color.WHITE,
                outlineWidth: 2,
                disableDepthTestDistance: Number.POSITIVE_INFINITY
            }
        });
        this.waypointEntities.push(entity);
    }

    _updatePathLine() {
        if (this.pathEntity) {
            this.viewer.entities.remove(this.pathEntity);
            this.pathEntity = null;
        }

        if (this.waypoints.length < 2) return;

        const positions = this.waypoints.map(wp => wp.position);

        this.pathEntity = this.viewer.entities.add({
            show: new Cesium.CallbackProperty(() => this.isNavigating, false),
            polyline: {
                positions: positions,
                width: 5,
                material: new Cesium.PolylineDashMaterialProperty({
                    color: Cesium.Color.CYAN,
                    dashLength: 10
                }),
                clampToGround: false
            }
        });
    }

    startNavigation() {
        if (this.waypoints.length === 0) {
            console.warn('æ²¡æœ‰è®¾ç½®èˆªç‚¹');
            return false;
        }

        this.isNavigating = true;
        this.currentWaypointIndex = 0;
        
        this.waypoints.forEach(wp => {
            wp.reached = false;
            wp.reachedTime = null;
            const entity = this.viewer.entities.getById(wp.id);
            if (entity) {
                if (entity.ellipsoid) {
                    entity.ellipsoid.material = Cesium.Color.YELLOW.withAlpha(0.2);
                    entity.ellipsoid.outlineColor = Cesium.Color.YELLOW;
                }
                if (entity.label) entity.label.fillColor = Cesium.Color.YELLOW;
            }
        });

        this._createDynamicPathEntities(); 

        this.emit('navigationStarted', {
            totalWaypoints: this.waypoints.length
        });

        return true;
    }

    stopNavigation() {
        this.isNavigating = false;
        this._destroyDynamicPathEntities(); 
        this.emit('navigationStopped');
    }

    _createDynamicPathEntities() {
        this._destroyDynamicPathEntities();

        if (!this.isNavigating) return;

        this.aircraftToFirstWaypointPathEntity = this.viewer.entities.add({
            show: new Cesium.CallbackProperty(() => this.isNavigating, false),
            polyline: {
                positions: new Cesium.CallbackProperty(() => {
                    if (this.isNavigating && this.lastAircraftPosition && this.currentWaypointIndex < this.waypoints.length) {
                        return [this.lastAircraftPosition, this.waypoints[this.currentWaypointIndex].position];
                    }
                    return [];
                }, false),
                width: 5,
                material: new Cesium.PolylineDashMaterialProperty({
                    color: Cesium.Color.CYAN,
                    dashLength: 10
                }),
                clampToGround: false
            }
        });
    }

    _destroyDynamicPathEntities() {
        if (this.aircraftToFirstWaypointPathEntity) {
            this.viewer.entities.remove(this.aircraftToFirstWaypointPathEntity);
            this.aircraftToFirstWaypointPathEntity = null;
        }
    }

    update(aircraftPosition) {
        this.lastAircraftPosition = aircraftPosition;

        if (!this.isNavigating || this.waypoints.length === 0 || this.currentWaypointIndex >= this.waypoints.length) {
            return null;
        }
        
        const currentWaypoint = this.waypoints[this.currentWaypointIndex];
        const distance = Cesium.Cartesian3.distance(aircraftPosition, currentWaypoint.position);
        
        const aircraftCarto = Cesium.Cartographic.fromCartesian(aircraftPosition);
        const bearing = CoordinateConverter.calculateBearing(
            Cesium.Math.toDegrees(aircraftCarto.longitude),
            Cesium.Math.toDegrees(aircraftCarto.latitude),
            currentWaypoint.longitude,
            currentWaypoint.latitude
        );
        
        const elevationDiff = this._calculateElevationDiff(aircraftPosition, currentWaypoint.position);

        if (distance <= this.completionRadius && !currentWaypoint.reached) {
            currentWaypoint.reached = true;
            currentWaypoint.reachedTime = Date.now();
            
            const entity = this.viewer.entities.getById(currentWaypoint.id);
            if (entity) {
                if (entity.ellipsoid) {
                    entity.ellipsoid.material = Cesium.Color.LIMEGREEN.withAlpha(0.3);
                    entity.ellipsoid.outlineColor = Cesium.Color.LIMEGREEN;
                }
                if (entity.label) entity.label.fillColor = Cesium.Color.LIMEGREEN;
            }

            this.emit('waypointReached', {
                waypoint: currentWaypoint,
                index: this.currentWaypointIndex,
                remaining: this.waypoints.length - this.currentWaypointIndex - 1
            });

            this.currentWaypointIndex++;
            
            if (this.currentWaypointIndex >= this.waypoints.length) {
                this.isNavigating = false;
                this._destroyDynamicPathEntities();
                this.emit('navigationCompleted', { totalTime: this._calculateTotalTime() });
                return null;
            }
        }

        return {
            currentWaypoint: this.waypoints[this.currentWaypointIndex],
            currentIndex: this.currentWaypointIndex,
            totalWaypoints: this.waypoints.length,
            distance,
            bearing,
            elevationDiff,
            eta: this._calculateETA(distance, 200)
        };
    }

    _calculateElevationDiff(from, to) {
        const fromCarto = Cesium.Cartographic.fromCartesian(from);
        const toCarto = Cesium.Cartographic.fromCartesian(to);
        return toCarto.height - fromCarto.height;
    }

    _calculateETA(distance, averageSpeed) {
        return distance / Math.max(averageSpeed, 1);
    }

    _calculateTotalTime() {
        if (this.waypoints.length === 0) return 0;
        const firstReachedWaypoint = this.waypoints.find(wp => wp.reachedTime !== null);
        const lastReachedWaypoint = [...this.waypoints].reverse().find(wp => wp.reachedTime !== null);
        if (!firstReachedWaypoint || !lastReachedWaypoint) return 0;
        return (lastReachedWaypoint.reachedTime - firstReachedWaypoint.reachedTime) / 1000;
    }

    clearWaypoints() {
        this.waypointEntities.forEach(entity => this.viewer.entities.remove(entity));
        if (this.pathEntity) this.viewer.entities.remove(this.pathEntity);
        this._destroyDynamicPathEntities(); 

        this.pathEntity = null;
        this.waypoints = [];
        this.waypointEntities = [];
        this.currentWaypointIndex = 0;
        this.isNavigating = false;

        this.emit('waypointsCleared');
    }

    removeWaypoint(waypointId) {
        const index = this.waypoints.findIndex(wp => wp.id === waypointId);
        if (index === -1) return;
        const waypoint = this.waypoints[index];
        const entity = this.viewer.entities.getById(waypointId);
        if (entity) this.viewer.entities.remove(entity);
        this.waypointEntities = this.waypointEntities.filter(e => e.id !== waypointId);
        this.waypoints.splice(index, 1);
        this._updatePathLine();
        this.emit('waypointRemoved', waypoint);
    }

    getWaypoints() {
        return [...this.waypoints];
    }

    async loadRoute(route) {
        this.clearWaypoints();
        if (route && route.waypoints) {
            for (const wp of route.waypoints) {
                await this.addWaypoint(wp.longitude, wp.latitude, wp.altitude, wp.name);
            }
        }
    }

    destroy() {
        this.clearWaypoints();
    }
}

--- End of File: src/helpers/WaypointManager.js ---

--- File: src/helpers/AudioManager.js ---

// src/helpers/AudioManager.js

export class AudioManager {
    constructor() {
        this.audioContext = new (window.AudioContext || window.webkitAudioContext)();
        this.buffers = {};
        this.sources = {};
        this.isEnabled = true;
        this.masterGain = this.audioContext.createGain(); // ä¸»éŸ³é‡æ§åˆ¶å™¨
        this.masterGain.connect(this.audioContext.destination);
        this.masterVolume = 0.5;
        this.masterGain.gain.setValueAtTime(this.masterVolume, this.audioContext.currentTime);
        this.isUnlocked = false;
    }

    async unlock() {
        if (this.isUnlocked) return true;
        if (this.audioContext.state === 'suspended') {
            await this.audioContext.resume();
        }
        this.isUnlocked = this.audioContext.state === 'running';
        if (this.isUnlocked) console.log('AudioContext unlocked successfully');
        return this.isUnlocked;
    }

    async loadSound(name, url) {
        try {
            const response = await fetch(url);
            const arrayBuffer = await response.arrayBuffer();
            const audioBuffer = await this.audioContext.decodeAudioData(arrayBuffer);
            this.buffers[name] = audioBuffer;
        } catch (error) {
            console.error(`Failed to load sound: ${name}`, error);
            throw error;
        }
    }

    play(name, options = {}) {
        if (!this.isEnabled || !this.buffers[name] || !this.isUnlocked || this.sources[name]) {
             // å¦‚æœå·²ç»åœ¨æ’­æ”¾ï¼Œåˆ™ä¸é‡å¤æ’­æ”¾
            return;
        }

        const source = this.audioContext.createBufferSource();
        source.buffer = this.buffers[name];
        source.loop = options.loop || false;

        const gainNode = this.audioContext.createGain();
        gainNode.gain.setValueAtTime(options.volume ?? 1.0, this.audioContext.currentTime);
        gainNode.connect(this.masterGain);
        source.connect(gainNode);

        source.start(0);

        this.sources[name] = { source, gainNode, baseVolume: options.volume ?? 1.0 };
    }

    stop(name) {
        if (this.sources[name]) {
            this.sources[name].source.stop(0);
            delete this.sources[name];
        }
    }
    
    // æ’­æ”¾ä¸€æ¬¡æ€§éŸ³æ•ˆ
    playOneShot(name, options = {}) {
        if (!this.isEnabled || !this.buffers[name] || !this.isUnlocked) return;

        const source = this.audioContext.createBufferSource();
        source.buffer = this.buffers[name];
        
        const gainNode = this.audioContext.createGain();
        gainNode.gain.setValueAtTime((options.volume ?? 1.0), this.audioContext.currentTime);
        
        gainNode.connect(this.masterGain);
        source.connect(gainNode);
        source.start(0);
    }

    updateEngineSound(speed, maxSpeed, stallSpeed) {
        const engine = this.sources.engine;
        if (!engine || !this.isUnlocked) return;

        const speedRatio = Math.max(0, Math.min(1, speed / maxSpeed));
        
        // æ›´æ–°éŸ³é‡
        const volumeFactor = speed < stallSpeed ? 0.3 : 0.5 + speedRatio * 0.5;
        const targetVolume = engine.baseVolume * volumeFactor;
        // ä½¿ç”¨çº¿æ€§æ¸å˜ï¼Œé¿å…éŸ³é‡çªå˜
        engine.gainNode.gain.linearRampToValueAtTime(targetVolume, this.audioContext.currentTime + 0.1);

        // æ›´æ–°æ’­æ”¾é€Ÿç‡ (éŸ³é«˜)
        const playbackRate = 0.8 + speedRatio * 0.7;
        engine.source.playbackRate.linearRampToValueAtTime(playbackRate, this.audioContext.currentTime + 0.1);
    }

    setMasterVolume(volume) {
        this.masterVolume = Math.max(0, Math.min(1, volume));
        this.masterGain.gain.setValueAtTime(this.masterVolume, this.audioContext.currentTime);
    }

    setEnabled(enabled) {
        this.isEnabled = enabled;
        if (!enabled) this.stopAll();
    }

    stopAll() {
        Object.keys(this.sources).forEach(name => this.stop(name));
    }

    destroy() {
        this.stopAll();
        this.audioContext.close();
        this.buffers = {};
    }
}

--- End of File: src/helpers/AudioManager.js ---

--- File: src/helpers/CoordinateConverter.js ---

// src/helpers/CoordinateConverter.js

import * as Cesium from 'cesium';

/**
 * åæ ‡ç³»è½¬æ¢å·¥å…·
 * Cesiumä½¿ç”¨ä¸œæ–¹ä¸º0åº¦ (East = 0Â°)
 * èˆªç©ºå¯¼èˆªä½¿ç”¨åŒ—æ–¹ä¸º0åº¦ (North = 0Â°)
 */
export class CoordinateConverter {
    /**
     * å°†èˆªç©ºæ–¹ä½è§’ï¼ˆåŒ—æ–¹0åº¦ï¼‰è½¬æ¢ä¸ºCesiumèˆªå‘è§’ï¼ˆä¸œæ–¹0åº¦ï¼‰
     * @param {number} bearing - èˆªç©ºæ–¹ä½è§’ï¼ˆåº¦ï¼‰
     * @returns {number} Cesiumèˆªå‘è§’ï¼ˆåº¦ï¼‰
     */
    static bearingToCesiumHeading(bearing) {
        return (bearing + 270 + 360) % 360;
    }

    /**
     * å°†Cesiumèˆªå‘è§’ï¼ˆä¸œæ–¹0åº¦ï¼‰è½¬æ¢ä¸ºèˆªç©ºæ–¹ä½è§’ï¼ˆåŒ—æ–¹0åº¦ï¼‰
     * @param {number} heading - Cesiumèˆªå‘è§’ï¼ˆåº¦ï¼‰
     * @returns {number} èˆªç©ºæ–¹ä½è§’ï¼ˆåº¦ï¼‰
     */
    static cesiumHeadingToBearing(heading) {
        return (heading + 450) % 360;
    }

    /**
     * è®¡ç®—ä¸¤ç‚¹ä¹‹é—´çš„æ–¹ä½è§’ï¼ˆåŒ—æ–¹0åº¦ï¼Œé¡ºæ—¶é’ˆï¼‰
     * @returns {number} æ–¹ä½è§’ï¼ˆåº¦ï¼‰
     */
    static calculateBearing(lon1, lat1, lon2, lat2) {
        const Ï†1 = Cesium.Math.toRadians(lat1);
        const Ï†2 = Cesium.Math.toRadians(lat2);
        const Î”Î» = Cesium.Math.toRadians(lon2 - lon1);
        const y = Math.sin(Î”Î») * Math.cos(Ï†2);
        const x = Math.cos(Ï†1) * Math.sin(Ï†2) - Math.sin(Ï†1) * Math.cos(Ï†2) * Math.cos(Î”Î»);
        const Î¸ = Math.atan2(y, x);
        return (Cesium.Math.toDegrees(Î¸) + 360) % 360;
    }
}

--- End of File: src/helpers/CoordinateConverter.js ---

